{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n */\n\n/**\n * @typedef {'left'|'center'|'right'|'none'} Align\n */\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding, markdownLineEndingOrSpace, markdownSpace } from 'micromark-util-character';\n/** @type {Extension} */\n\nexport const gfmTable = {\n  flow: {\n    null: {\n      tokenize: tokenizeTable,\n      resolve: resolveTable\n    }\n  }\n};\nconst nextPrefixedOrBlank = {\n  tokenize: tokenizeNextPrefixedOrBlank,\n  partial: true\n};\n/** @type {Resolver} */\n\nfunction resolveTable(events, context) {\n  let index = -1;\n  /** @type {boolean|undefined} */\n\n  let inHead;\n  /** @type {boolean|undefined} */\n\n  let inDelimiterRow;\n  /** @type {boolean|undefined} */\n\n  let inRow;\n  /** @type {number|undefined} */\n\n  let contentStart;\n  /** @type {number|undefined} */\n\n  let contentEnd;\n  /** @type {number|undefined} */\n\n  let cellStart;\n  /** @type {boolean|undefined} */\n\n  let seenCellInRow;\n\n  while (++index < events.length) {\n    const token = events[index][1];\n\n    if (inRow) {\n      if (token.type === 'temporaryTableCellContent') {\n        contentStart = contentStart || index;\n        contentEnd = index;\n      }\n\n      if ( // Combine separate content parts into one.\n      (token.type === 'tableCellDivider' || token.type === 'tableRow') && contentEnd) {\n        const content = {\n          type: 'tableContent',\n          start: events[contentStart][1].start,\n          end: events[contentEnd][1].end\n        };\n        /** @type {Token} */\n\n        const text = {\n          type: 'chunkText',\n          start: content.start,\n          end: content.end,\n          // @ts-expect-error It’s fine.\n          contentType: 'text'\n        };\n        events.splice(contentStart, contentEnd - contentStart + 1, ['enter', content, context], ['enter', text, context], ['exit', text, context], ['exit', content, context]);\n        index -= contentEnd - contentStart - 3;\n        contentStart = undefined;\n        contentEnd = undefined;\n      }\n    }\n\n    if (events[index][0] === 'exit' && cellStart !== undefined && cellStart + (seenCellInRow ? 0 : 1) < index && (token.type === 'tableCellDivider' || token.type === 'tableRow' && (cellStart + 3 < index || events[cellStart][1].type !== 'whitespace'))) {\n      const cell = {\n        type: inDelimiterRow ? 'tableDelimiter' : inHead ? 'tableHeader' : 'tableData',\n        start: events[cellStart][1].start,\n        end: events[index][1].end\n      };\n      events.splice(index + (token.type === 'tableCellDivider' ? 1 : 0), 0, ['exit', cell, context]);\n      events.splice(cellStart, 0, ['enter', cell, context]);\n      index += 2;\n      cellStart = index + 1;\n      seenCellInRow = true;\n    }\n\n    if (token.type === 'tableRow') {\n      inRow = events[index][0] === 'enter';\n\n      if (inRow) {\n        cellStart = index + 1;\n        seenCellInRow = false;\n      }\n    }\n\n    if (token.type === 'tableDelimiterRow') {\n      inDelimiterRow = events[index][0] === 'enter';\n\n      if (inDelimiterRow) {\n        cellStart = index + 1;\n        seenCellInRow = false;\n      }\n    }\n\n    if (token.type === 'tableHead') {\n      inHead = events[index][0] === 'enter';\n    }\n  }\n\n  return events;\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeTable(effects, ok, nok) {\n  const self = this;\n  /** @type {Array<Align>} */\n\n  const align = [];\n  let tableHeaderCount = 0;\n  /** @type {boolean|undefined} */\n\n  let seenDelimiter;\n  /** @type {boolean|undefined} */\n\n  let hasDash;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    // @ts-expect-error Custom.\n    effects.enter('table')._align = align;\n    effects.enter('tableHead');\n    effects.enter('tableRow'); // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      return cellDividerHead(code);\n    }\n\n    tableHeaderCount++;\n    effects.enter('temporaryTableCellContent'); // Can’t be space or eols at the start of a construct, so we’re in a cell.\n\n    return inCellContentHead(code);\n  }\n  /** @type {State} */\n\n\n  function cellDividerHead(code) {\n    effects.enter('tableCellDivider');\n    effects.consume(code);\n    effects.exit('tableCellDivider');\n    seenDelimiter = true;\n    return cellBreakHead;\n  }\n  /** @type {State} */\n\n\n  function cellBreakHead(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return atRowEndHead(code);\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace');\n      effects.consume(code);\n      return inWhitespaceHead;\n    }\n\n    if (seenDelimiter) {\n      seenDelimiter = undefined;\n      tableHeaderCount++;\n    }\n\n    if (code === 124) {\n      return cellDividerHead(code);\n    } // Anything else is cell content.\n\n\n    effects.enter('temporaryTableCellContent');\n    return inCellContentHead(code);\n  }\n  /** @type {State} */\n\n\n  function inWhitespaceHead(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return inWhitespaceHead;\n    }\n\n    effects.exit('whitespace');\n    return cellBreakHead(code);\n  }\n  /** @type {State} */\n\n\n  function inCellContentHead(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {\n      effects.exit('temporaryTableCellContent');\n      return cellBreakHead(code);\n    }\n\n    effects.consume(code);\n    return code === 92 ? inCellContentEscapeHead : inCellContentHead;\n  }\n  /** @type {State} */\n\n\n  function inCellContentEscapeHead(code) {\n    if (code === 92 || code === 124) {\n      effects.consume(code);\n      return inCellContentHead;\n    } // Anything else.\n\n\n    return inCellContentHead(code);\n  }\n  /** @type {State} */\n\n\n  function atRowEndHead(code) {\n    if (code === null) {\n      return nok(code);\n    }\n\n    effects.exit('tableRow');\n    effects.exit('tableHead');\n    const originalInterrupt = self.interrupt;\n    self.interrupt = true;\n    return effects.attempt({\n      tokenize: tokenizeRowEnd,\n      partial: true\n    }, function (code) {\n      self.interrupt = originalInterrupt;\n      effects.enter('tableDelimiterRow');\n      return atDelimiterRowBreak(code);\n    }, function (code) {\n      self.interrupt = originalInterrupt;\n      return nok(code);\n    })(code);\n  }\n  /** @type {State} */\n\n\n  function atDelimiterRowBreak(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return rowEndDelimiter(code);\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace');\n      effects.consume(code);\n      return inWhitespaceDelimiter;\n    }\n\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller');\n      effects.consume(code);\n      hasDash = true;\n      align.push('none');\n      return inFillerDelimiter;\n    }\n\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment');\n      effects.consume(code);\n      effects.exit('tableDelimiterAlignment');\n      align.push('left');\n      return afterLeftAlignment;\n    } // If we start with a pipe, we open a cell marker.\n\n\n    if (code === 124) {\n      effects.enter('tableCellDivider');\n      effects.consume(code);\n      effects.exit('tableCellDivider');\n      return atDelimiterRowBreak;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function inWhitespaceDelimiter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return inWhitespaceDelimiter;\n    }\n\n    effects.exit('whitespace');\n    return atDelimiterRowBreak(code);\n  }\n  /** @type {State} */\n\n\n  function inFillerDelimiter(code) {\n    if (code === 45) {\n      effects.consume(code);\n      return inFillerDelimiter;\n    }\n\n    effects.exit('tableDelimiterFiller');\n\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment');\n      effects.consume(code);\n      effects.exit('tableDelimiterAlignment');\n      align[align.length - 1] = align[align.length - 1] === 'left' ? 'center' : 'right';\n      return afterRightAlignment;\n    }\n\n    return atDelimiterRowBreak(code);\n  }\n  /** @type {State} */\n\n\n  function afterLeftAlignment(code) {\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller');\n      effects.consume(code);\n      hasDash = true;\n      return inFillerDelimiter;\n    } // Anything else is not ok.\n\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function afterRightAlignment(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return rowEndDelimiter(code);\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace');\n      effects.consume(code);\n      return inWhitespaceDelimiter;\n    } // `|`\n\n\n    if (code === 124) {\n      effects.enter('tableCellDivider');\n      effects.consume(code);\n      effects.exit('tableCellDivider');\n      return atDelimiterRowBreak;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function rowEndDelimiter(code) {\n    effects.exit('tableDelimiterRow'); // Exit if there was no dash at all, or if the header cell count is not the\n    // delimiter cell count.\n\n    if (!hasDash || tableHeaderCount !== align.length) {\n      return nok(code);\n    }\n\n    if (code === null) {\n      return tableClose(code);\n    }\n\n    return effects.check(nextPrefixedOrBlank, tableClose, effects.attempt({\n      tokenize: tokenizeRowEnd,\n      partial: true\n    }, factorySpace(effects, bodyStart, 'linePrefix', 4), tableClose))(code);\n  }\n  /** @type {State} */\n\n\n  function tableClose(code) {\n    effects.exit('table');\n    return ok(code);\n  }\n  /** @type {State} */\n\n\n  function bodyStart(code) {\n    effects.enter('tableBody');\n    return rowStartBody(code);\n  }\n  /** @type {State} */\n\n\n  function rowStartBody(code) {\n    effects.enter('tableRow'); // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      return cellDividerBody(code);\n    }\n\n    effects.enter('temporaryTableCellContent'); // Can’t be space or eols at the start of a construct, so we’re in a cell.\n\n    return inCellContentBody(code);\n  }\n  /** @type {State} */\n\n\n  function cellDividerBody(code) {\n    effects.enter('tableCellDivider');\n    effects.consume(code);\n    effects.exit('tableCellDivider');\n    return cellBreakBody;\n  }\n  /** @type {State} */\n\n\n  function cellBreakBody(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return atRowEndBody(code);\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace');\n      effects.consume(code);\n      return inWhitespaceBody;\n    } // `|`\n\n\n    if (code === 124) {\n      return cellDividerBody(code);\n    } // Anything else is cell content.\n\n\n    effects.enter('temporaryTableCellContent');\n    return inCellContentBody(code);\n  }\n  /** @type {State} */\n\n\n  function inWhitespaceBody(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return inWhitespaceBody;\n    }\n\n    effects.exit('whitespace');\n    return cellBreakBody(code);\n  }\n  /** @type {State} */\n\n\n  function inCellContentBody(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {\n      effects.exit('temporaryTableCellContent');\n      return cellBreakBody(code);\n    }\n\n    effects.consume(code);\n    return code === 92 ? inCellContentEscapeBody : inCellContentBody;\n  }\n  /** @type {State} */\n\n\n  function inCellContentEscapeBody(code) {\n    if (code === 92 || code === 124) {\n      effects.consume(code);\n      return inCellContentBody;\n    } // Anything else.\n\n\n    return inCellContentBody(code);\n  }\n  /** @type {State} */\n\n\n  function atRowEndBody(code) {\n    effects.exit('tableRow');\n\n    if (code === null) {\n      return tableBodyClose(code);\n    }\n\n    return effects.check(nextPrefixedOrBlank, tableBodyClose, effects.attempt({\n      tokenize: tokenizeRowEnd,\n      partial: true\n    }, factorySpace(effects, rowStartBody, 'linePrefix', 4), tableBodyClose))(code);\n  }\n  /** @type {State} */\n\n\n  function tableBodyClose(code) {\n    effects.exit('tableBody');\n    return tableClose(code);\n  }\n  /** @type {Tokenizer} */\n\n\n  function tokenizeRowEnd(effects, ok, nok) {\n    return start;\n    /** @type {State} */\n\n    function start(code) {\n      effects.enter('lineEnding');\n      effects.consume(code);\n      effects.exit('lineEnding');\n      return factorySpace(effects, prefixed, 'linePrefix');\n    }\n    /** @type {State} */\n\n\n    function prefixed(code) {\n      // Blank or interrupting line.\n      if (self.parser.lazy[self.now().line] || code === null || markdownLineEnding(code)) {\n        return nok(code);\n      }\n\n      const tail = self.events[self.events.length - 1]; // Indented code can interrupt delimiter and body rows.\n\n      if (!self.parser.constructs.disable.null.includes('codeIndented') && tail && tail[1].type === 'linePrefix' && tail[2].sliceSerialize(tail[1], true).length >= 4) {\n        return nok(code);\n      }\n\n      self._gfmTableDynamicInterruptHack = true;\n      return effects.check(self.parser.constructs.flow, function (code) {\n        self._gfmTableDynamicInterruptHack = false;\n        return nok(code);\n      }, function (code) {\n        self._gfmTableDynamicInterruptHack = false;\n        return ok(code);\n      })(code);\n    }\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeNextPrefixedOrBlank(effects, ok, nok) {\n  let size = 0;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    // This is a check, so we don’t care about tokens, but we open a bogus one\n    // so we’re valid.\n    effects.enter('check'); // EOL.\n\n    effects.consume(code);\n    return whitespace;\n  }\n  /** @type {State} */\n\n\n  function whitespace(code) {\n    if (code === -1 || code === 32) {\n      effects.consume(code);\n      size++;\n      return size === 4 ? ok : whitespace;\n    } // EOF or whitespace\n\n\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      return ok(code);\n    } // Anything else.\n\n\n    return nok(code);\n  }\n}","map":{"version":3,"sources":["/home/kali/Documents/cybersecurity-bounty-hunting-platform/client/node_modules/micromark-extension-gfm-table/lib/syntax.js"],"names":["factorySpace","markdownLineEnding","markdownLineEndingOrSpace","markdownSpace","gfmTable","flow","null","tokenize","tokenizeTable","resolve","resolveTable","nextPrefixedOrBlank","tokenizeNextPrefixedOrBlank","partial","events","context","index","inHead","inDelimiterRow","inRow","contentStart","contentEnd","cellStart","seenCellInRow","length","token","type","content","start","end","text","contentType","splice","undefined","cell","effects","ok","nok","self","align","tableHeaderCount","seenDelimiter","hasDash","code","enter","_align","cellDividerHead","inCellContentHead","consume","exit","cellBreakHead","atRowEndHead","inWhitespaceHead","inCellContentEscapeHead","originalInterrupt","interrupt","attempt","tokenizeRowEnd","atDelimiterRowBreak","rowEndDelimiter","inWhitespaceDelimiter","push","inFillerDelimiter","afterLeftAlignment","afterRightAlignment","tableClose","check","bodyStart","rowStartBody","cellDividerBody","inCellContentBody","cellBreakBody","atRowEndBody","inWhitespaceBody","inCellContentEscapeBody","tableBodyClose","prefixed","parser","lazy","now","line","tail","constructs","disable","includes","sliceSerialize","_gfmTableDynamicInterruptHack","size","whitespace"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n */\n\n/**\n * @typedef {'left'|'center'|'right'|'none'} Align\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\n\n/** @type {Extension} */\nexport const gfmTable = {\n  flow: {\n    null: {\n      tokenize: tokenizeTable,\n      resolve: resolveTable\n    }\n  }\n}\nconst nextPrefixedOrBlank = {\n  tokenize: tokenizeNextPrefixedOrBlank,\n  partial: true\n}\n/** @type {Resolver} */\n\nfunction resolveTable(events, context) {\n  let index = -1\n  /** @type {boolean|undefined} */\n\n  let inHead\n  /** @type {boolean|undefined} */\n\n  let inDelimiterRow\n  /** @type {boolean|undefined} */\n\n  let inRow\n  /** @type {number|undefined} */\n\n  let contentStart\n  /** @type {number|undefined} */\n\n  let contentEnd\n  /** @type {number|undefined} */\n\n  let cellStart\n  /** @type {boolean|undefined} */\n\n  let seenCellInRow\n\n  while (++index < events.length) {\n    const token = events[index][1]\n\n    if (inRow) {\n      if (token.type === 'temporaryTableCellContent') {\n        contentStart = contentStart || index\n        contentEnd = index\n      }\n\n      if (\n        // Combine separate content parts into one.\n        (token.type === 'tableCellDivider' || token.type === 'tableRow') &&\n        contentEnd\n      ) {\n        const content = {\n          type: 'tableContent',\n          start: events[contentStart][1].start,\n          end: events[contentEnd][1].end\n        }\n        /** @type {Token} */\n\n        const text = {\n          type: 'chunkText',\n          start: content.start,\n          end: content.end,\n          // @ts-expect-error It’s fine.\n          contentType: 'text'\n        }\n        events.splice(\n          contentStart,\n          contentEnd - contentStart + 1,\n          ['enter', content, context],\n          ['enter', text, context],\n          ['exit', text, context],\n          ['exit', content, context]\n        )\n        index -= contentEnd - contentStart - 3\n        contentStart = undefined\n        contentEnd = undefined\n      }\n    }\n\n    if (\n      events[index][0] === 'exit' &&\n      cellStart !== undefined &&\n      cellStart + (seenCellInRow ? 0 : 1) < index &&\n      (token.type === 'tableCellDivider' ||\n        (token.type === 'tableRow' &&\n          (cellStart + 3 < index ||\n            events[cellStart][1].type !== 'whitespace')))\n    ) {\n      const cell = {\n        type: inDelimiterRow\n          ? 'tableDelimiter'\n          : inHead\n          ? 'tableHeader'\n          : 'tableData',\n        start: events[cellStart][1].start,\n        end: events[index][1].end\n      }\n      events.splice(index + (token.type === 'tableCellDivider' ? 1 : 0), 0, [\n        'exit',\n        cell,\n        context\n      ])\n      events.splice(cellStart, 0, ['enter', cell, context])\n      index += 2\n      cellStart = index + 1\n      seenCellInRow = true\n    }\n\n    if (token.type === 'tableRow') {\n      inRow = events[index][0] === 'enter'\n\n      if (inRow) {\n        cellStart = index + 1\n        seenCellInRow = false\n      }\n    }\n\n    if (token.type === 'tableDelimiterRow') {\n      inDelimiterRow = events[index][0] === 'enter'\n\n      if (inDelimiterRow) {\n        cellStart = index + 1\n        seenCellInRow = false\n      }\n    }\n\n    if (token.type === 'tableHead') {\n      inHead = events[index][0] === 'enter'\n    }\n  }\n\n  return events\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeTable(effects, ok, nok) {\n  const self = this\n  /** @type {Array<Align>} */\n\n  const align = []\n  let tableHeaderCount = 0\n  /** @type {boolean|undefined} */\n\n  let seenDelimiter\n  /** @type {boolean|undefined} */\n\n  let hasDash\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    // @ts-expect-error Custom.\n    effects.enter('table')._align = align\n    effects.enter('tableHead')\n    effects.enter('tableRow') // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      return cellDividerHead(code)\n    }\n\n    tableHeaderCount++\n    effects.enter('temporaryTableCellContent') // Can’t be space or eols at the start of a construct, so we’re in a cell.\n\n    return inCellContentHead(code)\n  }\n  /** @type {State} */\n\n  function cellDividerHead(code) {\n    effects.enter('tableCellDivider')\n    effects.consume(code)\n    effects.exit('tableCellDivider')\n    seenDelimiter = true\n    return cellBreakHead\n  }\n  /** @type {State} */\n\n  function cellBreakHead(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return atRowEndHead(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceHead\n    }\n\n    if (seenDelimiter) {\n      seenDelimiter = undefined\n      tableHeaderCount++\n    }\n\n    if (code === 124) {\n      return cellDividerHead(code)\n    } // Anything else is cell content.\n\n    effects.enter('temporaryTableCellContent')\n    return inCellContentHead(code)\n  }\n  /** @type {State} */\n\n  function inWhitespaceHead(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return inWhitespaceHead\n    }\n\n    effects.exit('whitespace')\n    return cellBreakHead(code)\n  }\n  /** @type {State} */\n\n  function inCellContentHead(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {\n      effects.exit('temporaryTableCellContent')\n      return cellBreakHead(code)\n    }\n\n    effects.consume(code)\n    return code === 92 ? inCellContentEscapeHead : inCellContentHead\n  }\n  /** @type {State} */\n\n  function inCellContentEscapeHead(code) {\n    if (code === 92 || code === 124) {\n      effects.consume(code)\n      return inCellContentHead\n    } // Anything else.\n\n    return inCellContentHead(code)\n  }\n  /** @type {State} */\n\n  function atRowEndHead(code) {\n    if (code === null) {\n      return nok(code)\n    }\n\n    effects.exit('tableRow')\n    effects.exit('tableHead')\n    const originalInterrupt = self.interrupt\n    self.interrupt = true\n    return effects.attempt(\n      {\n        tokenize: tokenizeRowEnd,\n        partial: true\n      },\n      function (code) {\n        self.interrupt = originalInterrupt\n        effects.enter('tableDelimiterRow')\n        return atDelimiterRowBreak(code)\n      },\n      function (code) {\n        self.interrupt = originalInterrupt\n        return nok(code)\n      }\n    )(code)\n  }\n  /** @type {State} */\n\n  function atDelimiterRowBreak(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return rowEndDelimiter(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller')\n      effects.consume(code)\n      hasDash = true\n      align.push('none')\n      return inFillerDelimiter\n    }\n\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment')\n      effects.consume(code)\n      effects.exit('tableDelimiterAlignment')\n      align.push('left')\n      return afterLeftAlignment\n    } // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return atDelimiterRowBreak\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function inWhitespaceDelimiter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    effects.exit('whitespace')\n    return atDelimiterRowBreak(code)\n  }\n  /** @type {State} */\n\n  function inFillerDelimiter(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return inFillerDelimiter\n    }\n\n    effects.exit('tableDelimiterFiller')\n\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment')\n      effects.consume(code)\n      effects.exit('tableDelimiterAlignment')\n      align[align.length - 1] =\n        align[align.length - 1] === 'left' ? 'center' : 'right'\n      return afterRightAlignment\n    }\n\n    return atDelimiterRowBreak(code)\n  }\n  /** @type {State} */\n\n  function afterLeftAlignment(code) {\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller')\n      effects.consume(code)\n      hasDash = true\n      return inFillerDelimiter\n    } // Anything else is not ok.\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function afterRightAlignment(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return rowEndDelimiter(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    } // `|`\n\n    if (code === 124) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return atDelimiterRowBreak\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function rowEndDelimiter(code) {\n    effects.exit('tableDelimiterRow') // Exit if there was no dash at all, or if the header cell count is not the\n    // delimiter cell count.\n\n    if (!hasDash || tableHeaderCount !== align.length) {\n      return nok(code)\n    }\n\n    if (code === null) {\n      return tableClose(code)\n    }\n\n    return effects.check(\n      nextPrefixedOrBlank,\n      tableClose,\n      effects.attempt(\n        {\n          tokenize: tokenizeRowEnd,\n          partial: true\n        },\n        factorySpace(effects, bodyStart, 'linePrefix', 4),\n        tableClose\n      )\n    )(code)\n  }\n  /** @type {State} */\n\n  function tableClose(code) {\n    effects.exit('table')\n    return ok(code)\n  }\n  /** @type {State} */\n\n  function bodyStart(code) {\n    effects.enter('tableBody')\n    return rowStartBody(code)\n  }\n  /** @type {State} */\n\n  function rowStartBody(code) {\n    effects.enter('tableRow') // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      return cellDividerBody(code)\n    }\n\n    effects.enter('temporaryTableCellContent') // Can’t be space or eols at the start of a construct, so we’re in a cell.\n\n    return inCellContentBody(code)\n  }\n  /** @type {State} */\n\n  function cellDividerBody(code) {\n    effects.enter('tableCellDivider')\n    effects.consume(code)\n    effects.exit('tableCellDivider')\n    return cellBreakBody\n  }\n  /** @type {State} */\n\n  function cellBreakBody(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return atRowEndBody(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceBody\n    } // `|`\n\n    if (code === 124) {\n      return cellDividerBody(code)\n    } // Anything else is cell content.\n\n    effects.enter('temporaryTableCellContent')\n    return inCellContentBody(code)\n  }\n  /** @type {State} */\n\n  function inWhitespaceBody(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return inWhitespaceBody\n    }\n\n    effects.exit('whitespace')\n    return cellBreakBody(code)\n  }\n  /** @type {State} */\n\n  function inCellContentBody(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {\n      effects.exit('temporaryTableCellContent')\n      return cellBreakBody(code)\n    }\n\n    effects.consume(code)\n    return code === 92 ? inCellContentEscapeBody : inCellContentBody\n  }\n  /** @type {State} */\n\n  function inCellContentEscapeBody(code) {\n    if (code === 92 || code === 124) {\n      effects.consume(code)\n      return inCellContentBody\n    } // Anything else.\n\n    return inCellContentBody(code)\n  }\n  /** @type {State} */\n\n  function atRowEndBody(code) {\n    effects.exit('tableRow')\n\n    if (code === null) {\n      return tableBodyClose(code)\n    }\n\n    return effects.check(\n      nextPrefixedOrBlank,\n      tableBodyClose,\n      effects.attempt(\n        {\n          tokenize: tokenizeRowEnd,\n          partial: true\n        },\n        factorySpace(effects, rowStartBody, 'linePrefix', 4),\n        tableBodyClose\n      )\n    )(code)\n  }\n  /** @type {State} */\n\n  function tableBodyClose(code) {\n    effects.exit('tableBody')\n    return tableClose(code)\n  }\n  /** @type {Tokenizer} */\n\n  function tokenizeRowEnd(effects, ok, nok) {\n    return start\n    /** @type {State} */\n\n    function start(code) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return factorySpace(effects, prefixed, 'linePrefix')\n    }\n    /** @type {State} */\n\n    function prefixed(code) {\n      // Blank or interrupting line.\n      if (\n        self.parser.lazy[self.now().line] ||\n        code === null ||\n        markdownLineEnding(code)\n      ) {\n        return nok(code)\n      }\n\n      const tail = self.events[self.events.length - 1] // Indented code can interrupt delimiter and body rows.\n\n      if (\n        !self.parser.constructs.disable.null.includes('codeIndented') &&\n        tail &&\n        tail[1].type === 'linePrefix' &&\n        tail[2].sliceSerialize(tail[1], true).length >= 4\n      ) {\n        return nok(code)\n      }\n\n      self._gfmTableDynamicInterruptHack = true\n      return effects.check(\n        self.parser.constructs.flow,\n        function (code) {\n          self._gfmTableDynamicInterruptHack = false\n          return nok(code)\n        },\n        function (code) {\n          self._gfmTableDynamicInterruptHack = false\n          return ok(code)\n        }\n      )(code)\n    }\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeNextPrefixedOrBlank(effects, ok, nok) {\n  let size = 0\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    // This is a check, so we don’t care about tokens, but we open a bogus one\n    // so we’re valid.\n    effects.enter('check') // EOL.\n\n    effects.consume(code)\n    return whitespace\n  }\n  /** @type {State} */\n\n  function whitespace(code) {\n    if (code === -1 || code === 32) {\n      effects.consume(code)\n      size++\n      return size === 4 ? ok : whitespace\n    } // EOF or whitespace\n\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      return ok(code)\n    } // Anything else.\n\n    return nok(code)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}