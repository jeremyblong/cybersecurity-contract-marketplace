{"ast":null,"code":"\"use strict\";\n\nfunction _interopDefault(ex) {\n  return ex && \"object\" == typeof ex && \"default\" in ex ? ex.default : ex;\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\n\nvar react = _interopDefault(require(\"react\")),\n    reactDom = _interopDefault(require(\"react-dom\"));\n\nfunction _defineProperty(obj, key, value) {\n  return key in obj ? Object.defineProperty(obj, key, {\n    value: value,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : obj[key] = value, obj;\n}\n\nclass AbstractRecoilValue {\n  constructor(newKey) {\n    _defineProperty(this, \"key\", void 0), this.key = newKey;\n  }\n\n}\n\nclass RecoilState extends AbstractRecoilValue {}\n\nclass RecoilValueReadOnly extends AbstractRecoilValue {}\n\nvar Recoil_RecoilValue = {\n  AbstractRecoilValue: AbstractRecoilValue,\n  RecoilState: RecoilState,\n  RecoilValueReadOnly: RecoilValueReadOnly,\n  isRecoilValue: function (x) {\n    return x instanceof RecoilState || x instanceof RecoilValueReadOnly;\n  }\n},\n    Recoil_RecoilValue_1 = Recoil_RecoilValue.AbstractRecoilValue,\n    Recoil_RecoilValue_2 = Recoil_RecoilValue.RecoilState,\n    Recoil_RecoilValue_3 = Recoil_RecoilValue.RecoilValueReadOnly,\n    Recoil_RecoilValue_4 = Recoil_RecoilValue.isRecoilValue;\n\nfunction getCjsExportFromNamespace(n) {\n  return n && n.default || n;\n}\n\nvar require$$2 = getCjsExportFromNamespace(Object.freeze({\n  __proto__: null,\n  AbstractRecoilValue: Recoil_RecoilValue_1,\n  RecoilState: Recoil_RecoilValue_2,\n  RecoilValueReadOnly: Recoil_RecoilValue_3,\n  isRecoilValue: Recoil_RecoilValue_4\n}));\n\nclass DefaultValue {}\n\nconst DEFAULT_VALUE = new DefaultValue();\n\nclass RecoilValueNotReady extends Error {\n  constructor(key) {\n    super(\"Tried to set the value of Recoil selector \".concat(key, \" using an updater function, but it is an async selector in a pending or error state; this is not supported.\"));\n  }\n\n}\n\nconst nodes = new Map();\n\nclass NodeMissingError extends Error {}\n\nvar Recoil_Node = {\n  nodes: nodes,\n  registerNode: function (node) {\n    if (nodes.has(node.key)) {\n      node.key;\n    }\n\n    return nodes.set(node.key, node), null == node.set ? new require$$2.RecoilValueReadOnly(node.key) : new require$$2.RecoilState(node.key);\n  },\n  getNode: function (key) {\n    const node = nodes.get(key);\n    if (null == node) throw new NodeMissingError(\"Missing definition for RecoilValue: \\\"\".concat(key, \"\\\"\\\"\"));\n    return node;\n  },\n  NodeMissingError: NodeMissingError,\n  DefaultValue: DefaultValue,\n  DEFAULT_VALUE: DEFAULT_VALUE,\n  RecoilValueNotReady: RecoilValueNotReady\n};\nvar Recoil_Queue = {\n  enqueueExecution: function (s, f) {\n    f();\n  }\n};\nvar Recoil_CopyOnWrite = {\n  setByAddingToSet: function (set, v) {\n    const next = new Set(set);\n    return next.add(v), next;\n  },\n  setByDeletingFromSet: function (set, v) {\n    const next = new Set(set);\n    return next.delete(v), next;\n  },\n  mapBySettingInMap: function (map, k, v) {\n    const next = new Map(map);\n    return next.set(k, v), next;\n  },\n  mapByUpdatingInMap: function (map, k, updater) {\n    const next = new Map(map);\n    return next.set(k, updater(next.get(k))), next;\n  },\n  mapByDeletingFromMap: function (map, k) {\n    const next = new Map(map);\n    return next.delete(k), next;\n  }\n};\nvar Recoil_Tracing = {\n  trace: function (message, node, fn) {\n    return fn();\n  },\n  wrap: function (fn) {\n    return fn;\n  }\n};\nconst {\n  mapByDeletingFromMap: mapByDeletingFromMap$1,\n  mapBySettingInMap: mapBySettingInMap$1,\n  mapByUpdatingInMap: mapByUpdatingInMap$1,\n  setByAddingToSet: setByAddingToSet$1\n} = Recoil_CopyOnWrite,\n      {\n  getNode: getNode$1\n} = Recoil_Node,\n      emptyMap = Object.freeze(new Map()),\n      emptySet = Object.freeze(new Set());\n\nclass ReadOnlyRecoilValueError extends Error {}\n\nfunction getNodeLoadable(store, state, key) {\n  return getNode$1(key).get(store, state);\n}\n\nlet subscriptionID = 0;\nvar Recoil_FunctionalCore = {\n  getNodeLoadable: getNodeLoadable,\n  peekNodeLoadable: function (store, state, key) {\n    return getNodeLoadable(store, state, key)[1];\n  },\n  setNodeValue: function (store, state, key, newValue) {\n    const node = getNode$1(key);\n    if (null == node.set) throw new ReadOnlyRecoilValueError(\"Attempt to set read-only RecoilValue: \" + key);\n    const [newState, writtenNodes] = node.set(store, state, newValue);\n    return [newState, writtenNodes];\n  },\n  setUnvalidatedAtomValue: function (state, key, newValue) {\n    return { ...state,\n      atomValues: mapByDeletingFromMap$1(state.atomValues, key),\n      nonvalidatedAtoms: mapBySettingInMap$1(state.nonvalidatedAtoms, key, newValue),\n      dirtyAtoms: setByAddingToSet$1(state.dirtyAtoms, key)\n    };\n  },\n  subscribeComponentToNode: function (state, key, callback) {\n    const subID = subscriptionID++;\n    return [{ ...state,\n      nodeToComponentSubscriptions: mapByUpdatingInMap$1(state.nodeToComponentSubscriptions, key, subsForAtom => mapBySettingInMap$1(null != subsForAtom ? subsForAtom : emptyMap, subID, [\"TODO debug name\", callback]))\n    }, function (state) {\n      return { ...state,\n        nodeToComponentSubscriptions: mapByUpdatingInMap$1(state.nodeToComponentSubscriptions, key, subsForAtom => mapByDeletingFromMap$1(null != subsForAtom ? subsForAtom : emptyMap, subID))\n      };\n    }];\n  },\n  fireNodeSubscriptions: function (store, updatedNodes, when) {\n    var _store$getState$nextT;\n\n    const state = \"enqueue\" === when && null !== (_store$getState$nextT = store.getState().nextTree) && void 0 !== _store$getState$nextT ? _store$getState$nextT : store.getState().currentTree,\n          dependentNodes = function (state, keys) {\n      const dependentNodes = new Set(),\n            visitedNodes = new Set(),\n            visitingNodes = Array.from(keys);\n\n      for (let key = visitingNodes.pop(); key; key = visitingNodes.pop()) {\n        var _state$nodeToNodeSubs;\n\n        dependentNodes.add(key), visitedNodes.add(key);\n        const subscribedNodes = null !== (_state$nodeToNodeSubs = state.nodeToNodeSubscriptions.get(key)) && void 0 !== _state$nodeToNodeSubs ? _state$nodeToNodeSubs : emptySet;\n\n        for (const downstreamNode of subscribedNodes) visitedNodes.has(downstreamNode) || visitingNodes.push(downstreamNode);\n      }\n\n      return dependentNodes;\n    }(state, updatedNodes);\n\n    for (const key of dependentNodes) {\n      var _state$nodeToComponen;\n\n      (null !== (_state$nodeToComponen = state.nodeToComponentSubscriptions.get(key)) && void 0 !== _state$nodeToComponen ? _state$nodeToComponen : []).forEach(_ref => {\n        let [_debugName, cb] = _ref;\n        \"enqueue\" === when ? store.getState().queuedComponentCallbacks.push(cb) : cb(state);\n      });\n    }\n\n    Recoil_Tracing.trace(\"value became available, waking components\", Array.from(updatedNodes).join(\", \"), () => {\n      const resolvers = store.getState().suspendedComponentResolvers;\n      resolvers.forEach(r => r()), resolvers.clear();\n    });\n  },\n  detectCircularDependencies: function detectCircularDependencies(state, stack) {\n    if (!stack.length) return;\n    const leaf = stack[stack.length - 1],\n          downstream = state.nodeToNodeSubscriptions.get(leaf);\n    if (!(null == downstream ? void 0 : downstream.size)) return;\n    const root = stack[0];\n    if (downstream.has(root)) throw new Error(\"Recoil selector has circular dependencies: \" + [...stack, root].reverse().join(\" â†’ \"));\n\n    for (const next of downstream) detectCircularDependencies(state, [...stack, next]);\n  }\n};\n\nvar Recoil_mapMap = function (map, callback) {\n  const result = new Map();\n  return map.forEach((value, key) => {\n    result.set(key, callback(value, key));\n  }), result;\n};\n\nconst {\n  getNodeLoadable: getNodeLoadable$1,\n  peekNodeLoadable: peekNodeLoadable$1,\n  setNodeValue: setNodeValue$1,\n  setUnvalidatedAtomValue: setUnvalidatedAtomValue$1,\n  subscribeComponentToNode: subscribeComponentToNode$1\n} = Recoil_FunctionalCore,\n      {\n  RecoilValueNotReady: RecoilValueNotReady$1\n} = Recoil_Node,\n      {\n  AbstractRecoilValue: AbstractRecoilValue$1,\n  RecoilState: RecoilState$1,\n  RecoilValueReadOnly: RecoilValueReadOnly$1\n} = require$$2;\nvar Recoil_RecoilValueInterface = {\n  RecoilValueReadOnly: RecoilValueReadOnly$1,\n  AbstractRecoilValue: AbstractRecoilValue$1,\n  RecoilState: RecoilState$1,\n  valueFromValueOrUpdater: function (store, _ref2, valueOrUpdater) {\n    let {\n      key: key\n    } = _ref2;\n\n    if (\"function\" == typeof valueOrUpdater) {\n      var _storeState$nextTree;\n\n      const storeState = store.getState(),\n            state = null !== (_storeState$nextTree = storeState.nextTree) && void 0 !== _storeState$nextTree ? _storeState$nextTree : storeState.currentTree,\n            current = peekNodeLoadable$1(store, state, key);\n      if (\"loading\" === current.state) throw new RecoilValueNotReady$1(key);\n      if (\"hasError\" === current.state) throw current.contents;\n      return valueOrUpdater(current.contents);\n    }\n\n    return valueOrUpdater;\n  },\n  getRecoilValueAsLoadable: function (store, _ref3) {\n    let {\n      key: key\n    } = _ref3;\n    let result;\n    return Recoil_Tracing.trace(\"get RecoilValue\", key, () => store.replaceState(Recoil_Tracing.wrap(state => {\n      const [newState, loadable] = getNodeLoadable$1(store, state, key);\n      return result = loadable, newState;\n    }))), result;\n  },\n  setRecoilValue: function (store, _ref4, newValue) {\n    let {\n      key: key\n    } = _ref4;\n    Recoil_Tracing.trace(\"set RecoilValue\", key, () => store.replaceState(Recoil_Tracing.wrap(state => {\n      const [newState, writtenNodes] = setNodeValue$1(store, state, key, newValue);\n      return store.fireNodeSubscriptions(writtenNodes, \"enqueue\"), newState;\n    })));\n  },\n  setUnvalidatedRecoilValue: function (store, _ref5, newValue) {\n    let {\n      key: key\n    } = _ref5;\n    Recoil_Tracing.trace(\"set unvalidated persisted atom\", key, () => store.replaceState(Recoil_Tracing.wrap(state => {\n      const newState = setUnvalidatedAtomValue$1(state, key, newValue);\n      return store.fireNodeSubscriptions(new Set([key]), \"enqueue\"), newState;\n    })));\n  },\n  subscribeToRecoilValue: function (store, _ref6, callback) {\n    let {\n      key: key\n    } = _ref6;\n    let newState, releaseFn;\n    return Recoil_Tracing.trace(\"subscribe component to RecoilValue\", key, () => store.replaceState(Recoil_Tracing.wrap(state => ([newState, releaseFn] = subscribeComponentToNode$1(state, key, callback), newState)))), {\n      release: store => store.replaceState(releaseFn)\n    };\n  }\n};\n\nfunction makeEmptyTreeState() {\n  return {\n    transactionMetadata: {},\n    atomValues: new Map(),\n    nonvalidatedAtoms: new Map(),\n    dirtyAtoms: new Set(),\n    nodeDeps: new Map(),\n    nodeToNodeSubscriptions: new Map(),\n    nodeToComponentSubscriptions: new Map()\n  };\n}\n\nfunction makeStoreState(treeState) {\n  return {\n    currentTree: treeState,\n    nextTree: null,\n    transactionSubscriptions: new Map(),\n    queuedComponentCallbacks: [],\n    suspendedComponentResolvers: new Set()\n  };\n}\n\nvar Recoil_State = {\n  makeEmptyTreeState: makeEmptyTreeState,\n  makeEmptyStoreState: function () {\n    return makeStoreState(makeEmptyTreeState());\n  },\n  makeStoreState: makeStoreState\n};\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$1\n} = Recoil_Node,\n      {\n  getRecoilValueAsLoadable: getRecoilValueAsLoadable$1,\n  setRecoilValue: setRecoilValue$1,\n  valueFromValueOrUpdater: valueFromValueOrUpdater$1\n} = Recoil_RecoilValueInterface,\n      {\n  makeEmptyTreeState: makeEmptyTreeState$1,\n  makeStoreState: makeStoreState$1\n} = Recoil_State;\n\nclass Snapshot {\n  constructor(treeState) {\n    _defineProperty(this, \"_store\", void 0), _defineProperty(this, \"getLoadable\", recoilValue => getRecoilValueAsLoadable$1(this._store, recoilValue)), _defineProperty(this, \"getPromise\", recoilValue => this.getLoadable(recoilValue).toPromise()), _defineProperty(this, \"map\", mapper => {\n      const mutableSnapshot = new MutableSnapshot(this._store.getState().currentTree);\n      mapper(mutableSnapshot);\n      return cloneSnapshot(mutableSnapshot.getStore_INTERNAL().getState().currentTree);\n    }), _defineProperty(this, \"asyncMap\", async mapper => {\n      const mutableSnapshot = new MutableSnapshot(this._store.getState().currentTree);\n      await mapper(mutableSnapshot);\n      return cloneSnapshot(mutableSnapshot.getStore_INTERNAL().getState().currentTree);\n    }), this._store = function (treeState) {\n      const storeState = makeStoreState$1(treeState);\n      return {\n        getState: () => storeState,\n        replaceState: replacer => {\n          storeState.currentTree = replacer(storeState.currentTree);\n        },\n        subscribeToTransactions: () => {\n          throw new Error(\"Cannot subscribe to Snapshots\");\n        },\n        addTransactionMetadata: () => {\n          throw new Error(\"Cannot subscribe to Snapshots\");\n        },\n        fireNodeSubscriptions: () => {}\n      };\n    }(treeState);\n  }\n\n  getStore_INTERNAL() {\n    return this._store;\n  }\n\n}\n\nfunction cloneTreeState(treeState) {\n  return {\n    transactionMetadata: { ...treeState.transactionMetadata\n    },\n    atomValues: new Map(treeState.atomValues),\n    nonvalidatedAtoms: new Map(treeState.nonvalidatedAtoms),\n    dirtyAtoms: new Set(treeState.dirtyAtoms),\n    nodeDeps: new Map(treeState.nodeDeps),\n    nodeToNodeSubscriptions: Recoil_mapMap(treeState.nodeToNodeSubscriptions, keys => new Set(keys)),\n    nodeToComponentSubscriptions: new Map()\n  };\n}\n\nfunction cloneSnapshot(treeState) {\n  return new Snapshot(cloneTreeState(treeState));\n}\n\nclass MutableSnapshot extends Snapshot {\n  constructor(treeState) {\n    super(cloneTreeState(treeState)), _defineProperty(this, \"set\", (recoilState, newValueOrUpdater) => {\n      const store = this.getStore_INTERNAL(),\n            newValue = valueFromValueOrUpdater$1(store, recoilState, newValueOrUpdater);\n      setRecoilValue$1(store, recoilState, newValue);\n    }), _defineProperty(this, \"reset\", recoilState => setRecoilValue$1(this.getStore_INTERNAL(), recoilState, DEFAULT_VALUE$1));\n  }\n\n}\n\nvar Recoil_Snapshot = {\n  Snapshot: Snapshot,\n  MutableSnapshot: MutableSnapshot,\n  freshSnapshot: function () {\n    return new Snapshot(makeEmptyTreeState$1());\n  },\n  cloneSnapshot: cloneSnapshot\n},\n    Recoil_Snapshot_1 = Recoil_Snapshot.Snapshot,\n    Recoil_Snapshot_2 = Recoil_Snapshot.MutableSnapshot,\n    Recoil_Snapshot_3 = Recoil_Snapshot.freshSnapshot,\n    Recoil_Snapshot_4 = Recoil_Snapshot.cloneSnapshot;\n\nvar Recoil_nullthrows = function (x, message) {\n  if (null != x) return x;\n  throw new Error(null != message ? message : \"Got unexpected null or undefined\");\n},\n    require$$6 = getCjsExportFromNamespace(Object.freeze({\n  __proto__: null,\n  Snapshot: Recoil_Snapshot_1,\n  MutableSnapshot: Recoil_Snapshot_2,\n  freshSnapshot: Recoil_Snapshot_3,\n  cloneSnapshot: Recoil_Snapshot_4\n}));\n\nconst {\n  useContext: useContext,\n  useEffect: useEffect,\n  useRef: useRef,\n  useState: useState\n} = react,\n      {\n  fireNodeSubscriptions: fireNodeSubscriptions$1,\n  setNodeValue: setNodeValue$2,\n  setUnvalidatedAtomValue: setUnvalidatedAtomValue$2\n} = Recoil_FunctionalCore,\n      {\n  freshSnapshot: freshSnapshot$1\n} = require$$6,\n      {\n  makeEmptyStoreState: makeEmptyStoreState$1,\n  makeStoreState: makeStoreState$2\n} = Recoil_State;\n\nfunction notInAContext() {\n  throw new Error(\"This component must be used inside a <RecoilRoot> component.\");\n}\n\nconst defaultStore = Object.freeze({\n  getState: notInAContext,\n  replaceState: notInAContext,\n  subscribeToTransactions: notInAContext,\n  addTransactionMetadata: notInAContext,\n  fireNodeSubscriptions: notInAContext\n});\n\nfunction startNextTreeIfNeeded(storeState) {\n  null === storeState.nextTree && (storeState.nextTree = { ...storeState.currentTree,\n    dirtyAtoms: new Set(),\n    transactionMetadata: {}\n  });\n}\n\nconst AppContext = react.createContext({\n  current: defaultStore\n}),\n      useStoreRef = () => useContext(AppContext);\n\nfunction Batcher(props) {\n  const storeRef = useStoreRef(),\n        [_, setState] = useState([]);\n  return props.setNotifyBatcherOfChange(() => setState({})), useEffect(() => {\n    Recoil_Queue.enqueueExecution(\"Batcher\", () => {\n      const storeState = storeRef.current.getState(),\n            {\n        nextTree: nextTree\n      } = storeState;\n      if (null === nextTree) return;\n      nextTree.dirtyAtoms.size && storeState.transactionSubscriptions.forEach(sub => sub(storeRef.current)), storeState.queuedComponentCallbacks.forEach(cb => cb(nextTree)), storeState.queuedComponentCallbacks.splice(0, storeState.queuedComponentCallbacks.length), storeState.currentTree = nextTree, storeState.nextTree = null;\n    });\n  }), null;\n}\n\nlet nextID = 0;\nvar Recoil_RecoilRoot_react = {\n  useStoreRef: useStoreRef,\n  RecoilRoot: function (_ref7) {\n    let {\n      initializeState_DEPRECATED: initializeState_DEPRECATED,\n      initializeState: initializeState,\n      children: children\n    } = _ref7;\n    let storeState;\n    const notifyBatcherOfChange = useRef(null),\n          store = {\n      getState: () => storeState.current,\n      replaceState: replacer => {\n        const storeState = storeRef.current.getState();\n        startNextTreeIfNeeded(storeState);\n        const nextTree = Recoil_nullthrows(storeState.nextTree),\n              replaced = replacer(nextTree);\n        replaced !== nextTree && (storeState.nextTree = replaced, Recoil_nullthrows(notifyBatcherOfChange.current)());\n      },\n      subscribeToTransactions: callback => {\n        const id = nextID++;\n        return storeRef.current.getState().transactionSubscriptions.set(id, callback), {\n          release: () => {\n            storeRef.current.getState().transactionSubscriptions.delete(id);\n          }\n        };\n      },\n      addTransactionMetadata: metadata => {\n        startNextTreeIfNeeded(storeRef.current.getState());\n\n        for (const k of Object.keys(metadata)) Recoil_nullthrows(storeRef.current.getState().nextTree).transactionMetadata[k] = metadata[k];\n      },\n      fireNodeSubscriptions: function (updatedNodes, when) {\n        fireNodeSubscriptions$1(storeRef.current, updatedNodes, when);\n      }\n    },\n          storeRef = useRef(store);\n    return storeState = useRef(null != initializeState_DEPRECATED ? function (store, initializeState) {\n      const initial = makeEmptyStoreState$1();\n      return initializeState({\n        set: (atom, value) => {\n          initial.currentTree = setNodeValue$2(store, initial.currentTree, atom.key, value)[0];\n        },\n        setUnvalidatedAtomValues: atomValues => {\n          atomValues.forEach((v, k) => {\n            initial.currentTree = setUnvalidatedAtomValue$2(initial.currentTree, k, v);\n          });\n        }\n      }), initial;\n    }(store, initializeState_DEPRECATED) : null != initializeState ? function (initializeState) {\n      const snapshot = freshSnapshot$1().map(initializeState);\n      return makeStoreState$2(snapshot.getStore_INTERNAL().getState().currentTree);\n    }(initializeState) : makeEmptyStoreState$1()), react.createElement(AppContext.Provider, {\n      value: storeRef\n    }, react.createElement(Batcher, {\n      setNotifyBatcherOfChange: function (x) {\n        notifyBatcherOfChange.current = x;\n      }\n    }), children);\n  }\n};\n\nvar Recoil_differenceSets = function (set) {\n  const ret = new Set();\n\n  for (var _len = arguments.length, setsWithValuesToRemove = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    setsWithValuesToRemove[_key - 1] = arguments[_key];\n  }\n\n  FIRST: for (const value of set) {\n    for (const otherSet of setsWithValuesToRemove) if (otherSet.has(value)) continue FIRST;\n\n    ret.add(value);\n  }\n\n  return ret;\n};\n\nvar Recoil_filterMap = function (map, callback) {\n  const result = new Map();\n\n  for (const [key, value] of map) callback(value, key) && result.set(key, value);\n\n  return result;\n};\n\nvar Recoil_intersectSets = function (first) {\n  const ret = new Set();\n\n  for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    rest[_key2 - 1] = arguments[_key2];\n  }\n\n  FIRST: for (const value of first) {\n    for (const otherSet of rest) if (!otherSet.has(value)) continue FIRST;\n\n    ret.add(value);\n  }\n\n  return ret;\n};\n\nvar Recoil_invariant = function (condition, message) {\n  if (!condition) throw new Error(message);\n};\n\nvar Recoil_mergeMaps = function () {\n  const result = new Map();\n\n  for (var _len3 = arguments.length, maps = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    maps[_key3] = arguments[_key3];\n  }\n\n  for (let i = 0; i < maps.length; i++) {\n    const iterator = maps[i].keys();\n    let nextKey;\n\n    for (; !(nextKey = iterator.next()).done;) result.set(nextKey.value, maps[i].get(nextKey.value));\n  }\n\n  return result;\n};\n\nconst {\n  useCallback: useCallback,\n  useEffect: useEffect$1,\n  useMemo: useMemo,\n  useRef: useRef$1,\n  useState: useState$1\n} = react,\n      {\n  peekNodeLoadable: peekNodeLoadable$2,\n  setNodeValue: setNodeValue$3\n} = Recoil_FunctionalCore,\n      {\n  DEFAULT_VALUE: DEFAULT_VALUE$2,\n  getNode: getNode$2,\n  nodes: nodes$1\n} = Recoil_Node,\n      {\n  useStoreRef: useStoreRef$1\n} = Recoil_RecoilRoot_react,\n      {\n  AbstractRecoilValue: AbstractRecoilValue$2,\n  getRecoilValueAsLoadable: getRecoilValueAsLoadable$2,\n  setRecoilValue: setRecoilValue$2,\n  setUnvalidatedRecoilValue: setUnvalidatedRecoilValue$1,\n  subscribeToRecoilValue: subscribeToRecoilValue$1,\n  valueFromValueOrUpdater: valueFromValueOrUpdater$2\n} = Recoil_RecoilValueInterface,\n      {\n  Snapshot: Snapshot$1,\n  cloneSnapshot: cloneSnapshot$1\n} = require$$6,\n      {\n  setByAddingToSet: setByAddingToSet$2\n} = Recoil_CopyOnWrite;\n\nfunction useInterface() {\n  const storeRef = useStoreRef$1(),\n        [_, forceUpdate] = useState$1([]),\n        recoilValuesUsed = useRef$1(new Set());\n  recoilValuesUsed.current = new Set();\n  const previousSubscriptions = useRef$1(new Set()),\n        subscriptions = useRef$1(new Map()),\n        unsubscribeFrom = useCallback(key => {\n    const sub = subscriptions.current.get(key);\n    sub && (sub.release(storeRef.current), subscriptions.current.delete(key));\n  }, [storeRef, subscriptions]);\n  return useEffect$1(() => {\n    const store = storeRef.current;\n\n    function updateState(_state, key) {\n      subscriptions.current.has(key) && forceUpdate([]);\n    }\n\n    Recoil_differenceSets(recoilValuesUsed.current, previousSubscriptions.current).forEach(key => {\n      if (subscriptions.current.has(key)) return;\n      const sub = subscribeToRecoilValue$1(store, new AbstractRecoilValue$2(key), state => {\n        Recoil_Tracing.trace(\"RecoilValue subscription fired\", key, () => {\n          updateState(0, key);\n        });\n      });\n      subscriptions.current.set(key, sub), Recoil_Tracing.trace(\"initial update on subscribing\", key, () => {\n        updateState(store.getState(), key);\n      });\n    }), Recoil_differenceSets(previousSubscriptions.current, recoilValuesUsed.current).forEach(key => {\n      unsubscribeFrom(key);\n    }), previousSubscriptions.current = recoilValuesUsed.current;\n  }), useEffect$1(() => {\n    const subs = subscriptions.current;\n    return () => subs.forEach((_, key) => unsubscribeFrom(key));\n  }, [unsubscribeFrom]), useMemo(() => {\n    function useSetRecoilState(recoilState) {\n      return newValueOrUpdater => {\n        const newValue = valueFromValueOrUpdater$2(storeRef.current, recoilState, newValueOrUpdater);\n        setRecoilValue$2(storeRef.current, recoilState, newValue);\n      };\n    }\n\n    function useRecoilValueLoadable(recoilValue) {\n      return recoilValuesUsed.current.has(recoilValue.key) || (recoilValuesUsed.current = setByAddingToSet$2(recoilValuesUsed.current, recoilValue.key)), getRecoilValueAsLoadable$2(storeRef.current, recoilValue);\n    }\n\n    function useRecoilValue(recoilValue) {\n      return function (loadable, atom, storeRef) {\n        if (\"hasValue\" === loadable.state) return loadable.contents;\n\n        if (\"loading\" === loadable.state) {\n          throw new Promise(resolve => {\n            storeRef.current.getState().suspendedComponentResolvers.add(resolve);\n          });\n        }\n\n        throw \"hasError\" === loadable.state ? loadable.contents : new Error(\"Invalid value of loadable atom \\\"\".concat(atom.key, \"\\\"\"));\n      }(useRecoilValueLoadable(recoilValue), recoilValue, storeRef);\n    }\n\n    return {\n      getRecoilValue: useRecoilValue,\n      getRecoilValueLoadable: useRecoilValueLoadable,\n      getRecoilState: function (recoilState) {\n        return [useRecoilValue(recoilState), useSetRecoilState(recoilState)];\n      },\n      getRecoilStateLoadable: function (recoilState) {\n        return [useRecoilValueLoadable(recoilState), useSetRecoilState(recoilState)];\n      },\n      getSetRecoilState: useSetRecoilState,\n      getResetRecoilState: function (recoilState) {\n        return () => setRecoilValue$2(storeRef.current, recoilState, DEFAULT_VALUE$2);\n      }\n    };\n  }, [recoilValuesUsed, storeRef]);\n}\n\nfunction useTransactionSubscription(callback) {\n  const storeRef = useStoreRef$1();\n  useEffect$1(() => storeRef.current.subscribeToTransactions(callback).release, [callback, storeRef]);\n}\n\nfunction useTreeStateClone_DEPRECATED() {\n  const [_, setState] = useState$1(0);\n  useTransactionSubscription(useCallback(() => setState(x => x + 1), []));\n  const storeRef = useStoreRef$1();\n  return {\n    transactionMetadata: { ...(state = storeRef.current.getState().currentTree).transactionMetadata\n    },\n    atomValues: new Map(state.atomValues),\n    nonvalidatedAtoms: new Map(state.nonvalidatedAtoms),\n    dirtyAtoms: new Set(state.dirtyAtoms),\n    nodeDeps: new Map(state.nodeDeps),\n    nodeToNodeSubscriptions: Recoil_mapMap(state.nodeToNodeSubscriptions, keys => new Set(keys)),\n    nodeToComponentSubscriptions: Recoil_mapMap(state.nodeToComponentSubscriptions, subsByAtom => new Map(subsByAtom))\n  };\n  var state;\n}\n\nfunction externallyVisibleAtomValuesInState(state) {\n  const atomValues = state.atomValues,\n        persistedAtomContentsValues = Recoil_mapMap(Recoil_filterMap(atomValues, (v, k) => {\n    var _node$options;\n\n    const persistence = null === (_node$options = getNode$2(k).options) || void 0 === _node$options ? void 0 : _node$options.persistence_UNSTABLE;\n    return null != persistence && \"none\" !== persistence.type && \"hasValue\" === v.state;\n  }), v => v.contents);\n  return Recoil_mergeMaps(state.nonvalidatedAtoms, persistedAtomContentsValues);\n}\n\nfunction useGotoRecoilSnapshot() {\n  const storeRef = useStoreRef$1();\n  return useCallback(snapshot => {\n    reactDom.unstable_batchedUpdates(() => {\n      storeRef.current.replaceState(prevState => {\n        const nextState = snapshot.getStore_INTERNAL().getState().currentTree,\n              updatedKeys = new Set();\n\n        for (const keys of [prevState.atomValues.keys(), nextState.atomValues.keys()]) for (const key of keys) {\n          var _prevState$atomValues, _nextState$atomValues;\n\n          (null === (_prevState$atomValues = prevState.atomValues.get(key)) || void 0 === _prevState$atomValues ? void 0 : _prevState$atomValues.contents) !== (null === (_nextState$atomValues = nextState.atomValues.get(key)) || void 0 === _nextState$atomValues ? void 0 : _nextState$atomValues.contents) && updatedKeys.add(key);\n        }\n\n        return storeRef.current.fireNodeSubscriptions(updatedKeys, \"enqueue\"), { ...nextState,\n          nodeToComponentSubscriptions: prevState.nodeToComponentSubscriptions\n        };\n      });\n    });\n  }, [storeRef]);\n}\n\nclass Sentinel {}\n\nconst SENTINEL = new Sentinel();\nvar Recoil_Hooks = {\n  useRecoilCallback: function (fn, deps) {\n    const storeRef = useStoreRef$1(),\n          gotoSnapshot = useGotoRecoilSnapshot();\n    return useCallback(function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      const snapshot = cloneSnapshot$1(storeRef.current.getState().currentTree);\n\n      function set(recoilState, newValueOrUpdater) {\n        const newValue = valueFromValueOrUpdater$2(storeRef.current, recoilState, newValueOrUpdater);\n        setRecoilValue$2(storeRef.current, recoilState, newValue);\n      }\n\n      function reset(recoilState) {\n        setRecoilValue$2(storeRef.current, recoilState, DEFAULT_VALUE$2);\n      }\n\n      let ret = SENTINEL;\n      return reactDom.unstable_batchedUpdates(() => {\n        ret = fn({\n          set: set,\n          reset: reset,\n          snapshot: snapshot,\n          gotoSnapshot: gotoSnapshot\n        })(...args);\n      }), ret instanceof Sentinel && Recoil_invariant(!1), ret;\n    }, null != deps ? [...deps, storeRef] : void 0);\n  },\n  useRecoilValue: function (recoilValue) {\n    return useInterface().getRecoilValue(recoilValue);\n  },\n  useRecoilValueLoadable: function (recoilValue) {\n    return useInterface().getRecoilValueLoadable(recoilValue);\n  },\n  useRecoilState: function (recoilState) {\n    const recoilInterface = useInterface(),\n          [value] = recoilInterface.getRecoilState(recoilState);\n    return [value, useCallback(recoilInterface.getSetRecoilState(recoilState), [recoilState])];\n  },\n  useRecoilStateLoadable: function (recoilState) {\n    const recoilInterface = useInterface(),\n          [value] = recoilInterface.getRecoilStateLoadable(recoilState);\n    return [value, useCallback(recoilInterface.getSetRecoilState(recoilState), [recoilState])];\n  },\n  useSetRecoilState: function (recoilState) {\n    return useCallback(useInterface().getSetRecoilState(recoilState), [recoilState]);\n  },\n  useResetRecoilState: function (recoilState) {\n    return useCallback(useInterface().getResetRecoilState(recoilState), [recoilState]);\n  },\n  useRecoilInterface: useInterface,\n  useSnapshotWithStateChange_DEPRECATED: function (transaction) {\n    const storeRef = useStoreRef$1();\n    let snapshot = useTreeStateClone_DEPRECATED();\n    transaction((_ref8, updater) => {\n      let {\n        key: key\n      } = _ref8;\n      [snapshot] = setNodeValue$3(storeRef.current, snapshot, key, peekNodeLoadable$2(storeRef.current, snapshot, key).map(updater));\n    });\n    const atomValues = Recoil_mapMap(snapshot.atomValues, v => v.contents),\n          updatedAtoms = Recoil_intersectSets(snapshot.dirtyAtoms, new Set(atomValues.keys()));\n    return {\n      atomValues: atomValues,\n      updatedAtoms: updatedAtoms\n    };\n  },\n  useTransactionSubscription_DEPRECATED: useTransactionSubscription,\n  useTransactionObservation_DEPRECATED: function (callback) {\n    useTransactionSubscription(useCallback(store => {\n      const previousState = store.getState().currentTree;\n      let nextState = store.getState().nextTree;\n      nextState || (nextState = store.getState().currentTree);\n      const atomValues = externallyVisibleAtomValuesInState(nextState),\n            previousAtomValues = externallyVisibleAtomValuesInState(previousState),\n            atomInfo = Recoil_mapMap(nodes$1, node => {\n        var _node$options$persist, _node$options2, _node$options2$persis, _node$options$persist2, _node$options3, _node$options3$persis;\n\n        return {\n          persistence_UNSTABLE: {\n            type: null !== (_node$options$persist = null === (_node$options2 = node.options) || void 0 === _node$options2 || null === (_node$options2$persis = _node$options2.persistence_UNSTABLE) || void 0 === _node$options2$persis ? void 0 : _node$options2$persis.type) && void 0 !== _node$options$persist ? _node$options$persist : \"none\",\n            backButton: null !== (_node$options$persist2 = null === (_node$options3 = node.options) || void 0 === _node$options3 || null === (_node$options3$persis = _node$options3.persistence_UNSTABLE) || void 0 === _node$options3$persis ? void 0 : _node$options3$persis.backButton) && void 0 !== _node$options$persist2 && _node$options$persist2\n          }\n        };\n      }),\n            modifiedAtoms = new Set(nextState.dirtyAtoms);\n      callback({\n        atomValues: atomValues,\n        previousAtomValues: previousAtomValues,\n        atomInfo: atomInfo,\n        modifiedAtoms: modifiedAtoms,\n        transactionMetadata: { ...nextState.transactionMetadata\n        }\n      });\n    }, [callback]));\n  },\n  useRecoilTransactionObserver: function (callback) {\n    useTransactionSubscription(useCallback(store => {\n      const previousState = store.getState().currentTree;\n      let nextState = store.getState().nextTree;\n      nextState || (nextState = previousState), callback({\n        snapshot: cloneSnapshot$1(nextState),\n        previousSnapshot: cloneSnapshot$1(previousState)\n      });\n    }, [callback]));\n  },\n  useRecoilSnapshot: function () {\n    const store = useStoreRef$1(),\n          [snapshot, setSnapshot] = useState$1(() => cloneSnapshot$1(store.current.getState().currentTree));\n    return useTransactionSubscription(useCallback(store => {\n      var _store$getState$nextT;\n\n      return setSnapshot(cloneSnapshot$1(null !== (_store$getState$nextT = store.getState().nextTree) && void 0 !== _store$getState$nextT ? _store$getState$nextT : store.getState().currentTree));\n    }, [])), snapshot;\n  },\n  useGoToSnapshot_DEPRECATED: function () {\n    const storeRef = useStoreRef$1();\n    return snapshot => {\n      reactDom.unstable_batchedUpdates(() => {\n        snapshot.updatedAtoms.forEach(key => {\n          setRecoilValue$2(storeRef.current, new AbstractRecoilValue$2(key), snapshot.atomValues.get(key));\n        });\n      });\n    };\n  },\n  useGotoRecoilSnapshot: useGotoRecoilSnapshot,\n  useSetUnvalidatedAtomValues: function () {\n    const storeRef = useStoreRef$1();\n    return function (values) {\n      let transactionMetadata = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      reactDom.unstable_batchedUpdates(() => {\n        storeRef.current.addTransactionMetadata(transactionMetadata), values.forEach((value, key) => setUnvalidatedRecoilValue$1(storeRef.current, new AbstractRecoilValue$2(key), value));\n      });\n    };\n  }\n};\n\nvar Recoil_isPromise = function (p) {\n  return !!p && \"function\" == typeof p.then;\n};\n\nconst loadableAccessors = {\n  getValue() {\n    if (\"hasValue\" !== this.state) throw this.contents;\n    return this.contents;\n  },\n\n  toPromise() {\n    return \"hasValue\" === this.state ? Promise.resolve(this.contents) : \"hasError\" === this.state ? Promise.reject(this.contents) : this.contents;\n  },\n\n  valueMaybe() {\n    return \"hasValue\" === this.state ? this.contents : void 0;\n  },\n\n  valueOrThrow() {\n    if (\"hasValue\" !== this.state) throw new Error(\"Loadable expected value, but in \\\"\".concat(this.state, \"\\\" state\"));\n    return this.contents;\n  },\n\n  errorMaybe() {\n    return \"hasError\" === this.state ? this.contents : void 0;\n  },\n\n  errorOrThrow() {\n    if (\"hasError\" !== this.state) throw new Error(\"Loadable expected error, but in \\\"\".concat(this.state, \"\\\" state\"));\n    return this.contents;\n  },\n\n  promiseMaybe() {\n    return \"loading\" === this.state ? this.contents : void 0;\n  },\n\n  promiseOrThrow() {\n    if (\"loading\" !== this.state) throw new Error(\"Loadable expected promise, but in \\\"\".concat(this.state, \"\\\" state\"));\n    return this.contents;\n  },\n\n  map(map) {\n    if (\"hasError\" === this.state) return this;\n    if (\"hasValue\" === this.state) try {\n      const next = map(this.contents);\n      return Recoil_isPromise(next) ? loadableWithPromise(next) : loadableWithValue(next);\n    } catch (e) {\n      return Recoil_isPromise(e) ? loadableWithPromise(e.next(() => map(this.contents))) : loadableWithError(e);\n    }\n    if (\"loading\" === this.state) return loadableWithPromise(this.contents.then(map).catch(e => {\n      if (Recoil_isPromise(e)) return e.then(() => map(this.contents));\n      throw e;\n    }));\n    throw new Error(\"Invalid Loadable state\");\n  }\n\n};\n\nfunction loadableWithValue(value) {\n  return Object.freeze({\n    state: \"hasValue\",\n    contents: value,\n    ...loadableAccessors\n  });\n}\n\nfunction loadableWithError(error) {\n  return Object.freeze({\n    state: \"hasError\",\n    contents: error,\n    ...loadableAccessors\n  });\n}\n\nfunction loadableWithPromise(promise) {\n  return Object.freeze({\n    state: \"loading\",\n    contents: promise,\n    ...loadableAccessors\n  });\n}\n\nvar Recoil_Loadable = {\n  loadableWithValue: loadableWithValue,\n  loadableWithError: loadableWithError,\n  loadableWithPromise: loadableWithPromise,\n  loadableLoading: function () {\n    return loadableWithPromise(new Promise(() => {}));\n  },\n  loadableAll: function (inputs) {\n    return inputs.every(i => \"hasValue\" === i.state) ? loadableWithValue(inputs.map(i => i.contents)) : inputs.some(i => \"hasError\" === i.state) ? loadableWithError(Recoil_nullthrows(inputs.find(i => \"hasError\" === i.state), \"Invalid loadable passed to loadableAll\").contents) : loadableWithPromise(Promise.all(inputs.map(i => i.contents)));\n  }\n};\n\nvar Recoil_isNode = function (object) {\n  var _ownerDocument, _doc$defaultView;\n\n  if (\"undefined\" == typeof window) return !1;\n  const defaultView = null !== (_doc$defaultView = (null != object ? null !== (_ownerDocument = object.ownerDocument) && void 0 !== _ownerDocument ? _ownerDocument : object : document).defaultView) && void 0 !== _doc$defaultView ? _doc$defaultView : window;\n  return !(null == object || !(\"function\" == typeof defaultView.Node ? object instanceof defaultView.Node : \"object\" == typeof object && \"number\" == typeof object.nodeType && \"string\" == typeof object.nodeName));\n};\n\nvar Recoil_deepFreezeValue = function deepFreezeValue(value) {\n  if (\"object\" == typeof value && !function (value) {\n    if (null === value || \"object\" != typeof value) return !0;\n\n    switch (typeof value.$$typeof) {\n      case \"symbol\":\n      case \"number\":\n        return !0;\n    }\n\n    return null != value[\"@@__IMMUTABLE_ITERABLE__@@\"] || null != value[\"@@__IMMUTABLE_KEYED__@@\"] || null != value[\"@@__IMMUTABLE_INDEXED__@@\"] || null != value[\"@@__IMMUTABLE_ORDERED__@@\"] || null != value[\"@@__IMMUTABLE_RECORD__@@\"] || !!Recoil_isNode(value) || !!Recoil_isPromise(value);\n  }(value)) {\n    Object.freeze(value);\n\n    for (const key in value) if (Object.prototype.hasOwnProperty.call(value, key)) {\n      const prop = value[key];\n      \"object\" != typeof prop || null == prop || Object.isFrozen(prop) || deepFreezeValue(prop);\n    }\n\n    Object.seal(value);\n  }\n};\n\nconst LEAF = Symbol(\"ArrayKeyedMap\"),\n      emptyMap$1 = new Map();\n\nclass ArrayKeyedMap {\n  constructor(existing) {\n    if (this._base = new Map(), existing instanceof ArrayKeyedMap) for (const [k, v] of existing.entries()) this.set(k, v);else if (existing) for (const [k, v] of existing) this.set(k, v);\n    return this;\n  }\n\n  get(key) {\n    const ks = Array.isArray(key) ? key : [key];\n    let map = this._base;\n    return ks.forEach(k => {\n      var _map$get;\n\n      map = null !== (_map$get = map.get(k)) && void 0 !== _map$get ? _map$get : emptyMap$1;\n    }), void 0 === map ? void 0 : map.get(LEAF);\n  }\n\n  set(key, value) {\n    const ks = Array.isArray(key) ? key : [key];\n    let map = this._base,\n        next = map;\n    return ks.forEach(k => {\n      next = map.get(k), next || (next = new Map(), map.set(k, next)), map = next;\n    }), next.set(LEAF, value), this;\n  }\n\n  delete(key) {\n    const ks = Array.isArray(key) ? key : [key];\n    let map = this._base,\n        next = map;\n    return ks.forEach(k => {\n      next = map.get(k), next || (next = new Map(), map.set(k, next)), map = next;\n    }), next.delete(LEAF), this;\n  }\n\n  entries() {\n    const answer = [];\n    return function recurse(level, prefix) {\n      level.forEach((v, k) => {\n        k === LEAF ? answer.push([prefix, v]) : recurse(v, prefix.concat(k));\n      });\n    }(this._base, []), answer.values();\n  }\n\n  toBuiltInMap() {\n    return new Map(this.entries());\n  }\n\n}\n\nvar Recoil_ArrayKeyedMap = ArrayKeyedMap;\n\nvar Recoil_cacheWithReferenceEquality = function () {\n  return new Recoil_ArrayKeyedMap();\n};\n\nvar Recoil_everySet = function (set, callback, context) {\n  const iterator = set.entries();\n  let current = iterator.next();\n\n  for (; !current.done;) {\n    const entry = current.value;\n    if (!callback.call(context, entry[1], entry[0], set)) return !1;\n    current = iterator.next();\n  }\n\n  return !0;\n};\n\nvar Recoil_equalsSet = function (one, two) {\n  return one.size === two.size && Recoil_everySet(one, value => two.has(value));\n};\n\nvar Recoil_PerformanceTimings = {\n  startPerfBlock: function (_id) {\n    return () => null;\n  }\n};\nObject.freeze(new Set());\nconst {\n  mapBySettingInMap: mapBySettingInMap$2,\n  mapByUpdatingInMap: mapByUpdatingInMap$2,\n  setByAddingToSet: setByAddingToSet$3,\n  setByDeletingFromSet: setByDeletingFromSet$1\n} = Recoil_CopyOnWrite,\n      {\n  detectCircularDependencies: detectCircularDependencies$1,\n  getNodeLoadable: getNodeLoadable$2,\n  setNodeValue: setNodeValue$4\n} = Recoil_FunctionalCore,\n      {\n  loadableWithError: loadableWithError$1,\n  loadableWithPromise: loadableWithPromise$1,\n  loadableWithValue: loadableWithValue$1\n} = Recoil_Loadable,\n      {\n  DEFAULT_VALUE: DEFAULT_VALUE$3,\n  RecoilValueNotReady: RecoilValueNotReady$2,\n  registerNode: registerNode$1\n} = Recoil_Node,\n      {\n  startPerfBlock: startPerfBlock$1\n} = Recoil_PerformanceTimings,\n      {\n  isRecoilValue: isRecoilValue$1\n} = require$$2,\n      emptySet$2 = Object.freeze(new Set());\n\nfunction cacheKeyFromDepValues(depValues) {\n  const answer = [];\n\n  for (const key of Array.from(depValues.keys()).sort()) {\n    const loadable = Recoil_nullthrows(depValues.get(key));\n    answer.push(key), answer.push(loadable.contents);\n  }\n\n  return answer;\n}\n\nvar Recoil_selector = function (options) {\n  const {\n    key: key,\n    get: get,\n    cacheImplementation_UNSTABLE: cacheImplementation\n  } = options,\n        set = null != options.set ? options.set : void 0;\n  let cache = null != cacheImplementation ? cacheImplementation : Recoil_cacheWithReferenceEquality();\n\n  function getFromCache(store, state) {\n    var _state$nodeDeps$get;\n\n    let newState = state;\n    const currentDeps = null !== (_state$nodeDeps$get = state.nodeDeps.get(key)) && void 0 !== _state$nodeDeps$get ? _state$nodeDeps$get : emptySet$2,\n          cacheKey = cacheKeyFromDepValues(new Map(Array.from(currentDeps).sort().map(depKey => {\n      const [nextState, loadable] = getNodeLoadable$2(store, newState, depKey);\n      return newState = nextState, [depKey, loadable];\n    }))),\n          cached = cache.get(cacheKey);\n    if (null != cached) return [newState, cached];\n\n    const [nextState, loadable, newDepValues] = function (store, state) {\n      var _state$nodeDeps$get2;\n\n      const [newStateFromEvaluate, loadable, newDepValues] = function (store, state) {\n        const endPerfBlock = startPerfBlock$1(key);\n        let newState = state;\n        const depValues = new Map();\n\n        function getRecoilValue(_ref9) {\n          let {\n            key: key\n          } = _ref9;\n          let loadable;\n          if ([newState, loadable] = getNodeLoadable$2(store, newState, key), depValues.set(key, loadable), \"hasValue\" === loadable.state) return loadable.contents;\n          throw loadable.contents;\n        }\n\n        try {\n          const output = get({\n            get: getRecoilValue\n          }),\n                result = isRecoilValue$1(output) ? getRecoilValue(output) : output,\n                loadable = Recoil_isPromise(result) ? loadableWithPromise$1(result.finally(endPerfBlock)) : (endPerfBlock(), loadableWithValue$1(result));\n          return [newState, loadable, depValues];\n        } catch (errorOrDepPromise) {\n          const loadable = Recoil_isPromise(errorOrDepPromise) ? loadableWithPromise$1(errorOrDepPromise.then(() => {\n            let loadable = loadableWithError$1(new Error(\"Internal Recoil Selector Error\"));\n            if (store.replaceState(asyncState => {\n              let newAsyncState;\n              return [newAsyncState, loadable] = getFromCache(store, asyncState), newAsyncState;\n            }), \"hasError\" === loadable.state) throw loadable.contents;\n            return loadable.contents;\n          }).finally(endPerfBlock)) : (endPerfBlock(), loadableWithError$1(errorOrDepPromise));\n          return [newState, loadable, depValues];\n        }\n      }(store, state);\n\n      let newState = newStateFromEvaluate;\n      const oldDeps = null !== (_state$nodeDeps$get2 = state.nodeDeps.get(key)) && void 0 !== _state$nodeDeps$get2 ? _state$nodeDeps$get2 : emptySet$2,\n            newDeps = new Set(newDepValues.keys());\n      newState = Recoil_equalsSet(oldDeps, newDeps) ? newState : { ...newState,\n        nodeDeps: mapBySettingInMap$2(newState.nodeDeps, key, newDeps)\n      };\n      const addedDeps = Recoil_differenceSets(newDeps, oldDeps),\n            removedDeps = Recoil_differenceSets(oldDeps, newDeps);\n\n      for (const upstreamNode of addedDeps) newState = { ...newState,\n        nodeToNodeSubscriptions: mapByUpdatingInMap$2(newState.nodeToNodeSubscriptions, upstreamNode, subs => setByAddingToSet$3(null != subs ? subs : emptySet$2, key))\n      };\n\n      for (const upstreamNode of removedDeps) newState = { ...newState,\n        nodeToNodeSubscriptions: mapByUpdatingInMap$2(newState.nodeToNodeSubscriptions, upstreamNode, subs => setByDeletingFromSet$1(null != subs ? subs : emptySet$2, key))\n      };\n\n      return [newState, loadable, newDepValues];\n    }(store, newState);\n\n    newState = nextState;\n    const newCacheKey = cacheKeyFromDepValues(newDepValues);\n    return function (store, cacheKey, loadable) {\n      \"loading\" !== loadable.state ? !0 == !options.dangerouslyAllowMutability && Recoil_deepFreezeValue(loadable.contents) : loadable.contents.then(result => (!0 == !options.dangerouslyAllowMutability && Recoil_deepFreezeValue(result), cache = cache.set(cacheKey, loadableWithValue$1(result)), store.fireNodeSubscriptions(new Set([key]), \"now\"), result)).catch(error => (Recoil_isPromise(error) || (!0 == !options.dangerouslyAllowMutability && Recoil_deepFreezeValue(error), cache = cache.set(cacheKey, loadableWithError$1(error)), store.fireNodeSubscriptions(new Set([key]), \"now\")), error)), cache = cache.set(cacheKey, loadable);\n    }(store, newCacheKey, loadable), [newState, loadable];\n  }\n\n  function myGet(store, state) {\n    return getFromCache(store, state);\n  }\n\n  if (null != set) {\n    return registerNode$1({\n      key: key,\n      options: options,\n      get: myGet,\n      set: function (store, state, newValue) {\n        let newState = state;\n        const writtenNodes = new Set();\n\n        function getRecoilValue(_ref10) {\n          let {\n            key: key\n          } = _ref10;\n          const [nextState, loadable] = getNodeLoadable$2(store, newState, key);\n          if (newState = nextState, \"hasValue\" === loadable.state) return loadable.contents;\n          throw \"loading\" === loadable.state ? new RecoilValueNotReady$2(key) : loadable.contents;\n        }\n\n        function setRecoilState(recoilState, valueOrUpdater) {\n          const newValue = \"function\" == typeof valueOrUpdater ? valueOrUpdater(getRecoilValue(recoilState)) : valueOrUpdater;\n          let written;\n          [newState, written] = setNodeValue$4(store, newState, recoilState.key, newValue), written.forEach(atom => writtenNodes.add(atom));\n        }\n\n        return set({\n          set: setRecoilState,\n          get: getRecoilValue,\n          reset: function (recoilState) {\n            setRecoilState(recoilState, DEFAULT_VALUE$3);\n          }\n        }, newValue), [newState, writtenNodes];\n      }\n    });\n  }\n\n  return registerNode$1({\n    key: key,\n    options: options,\n    get: myGet\n  });\n};\n\nconst {\n  loadableWithValue: loadableWithValue$2\n} = Recoil_Loadable,\n      {\n  DEFAULT_VALUE: DEFAULT_VALUE$4,\n  DefaultValue: DefaultValue$1,\n  registerNode: registerNode$2\n} = Recoil_Node,\n      {\n  isRecoilValue: isRecoilValue$2\n} = require$$2,\n      {\n  mapByDeletingFromMap: mapByDeletingFromMap$2,\n  mapBySettingInMap: mapBySettingInMap$3,\n  setByAddingToSet: setByAddingToSet$4\n} = Recoil_CopyOnWrite;\n\nfunction atom(options) {\n  const {\n    default: optionsDefault,\n    ...restOptions\n  } = options;\n  return isRecoilValue$2(optionsDefault) || Recoil_isPromise(optionsDefault) ? function (options) {\n    const base = atom({ ...options,\n      default: DEFAULT_VALUE$4,\n      persistence_UNSTABLE: void 0 === options.persistence_UNSTABLE ? void 0 : { ...options.persistence_UNSTABLE,\n        validator: storedValue => storedValue instanceof DefaultValue$1 ? storedValue : Recoil_nullthrows(options.persistence_UNSTABLE).validator(storedValue, DEFAULT_VALUE$4)\n      }\n    });\n    return Recoil_selector({\n      key: options.key + \"__withFallback\",\n      get: _ref11 => {\n        let {\n          get: get\n        } = _ref11;\n        const baseValue = get(base);\n        return baseValue instanceof DefaultValue$1 ? options.default : baseValue;\n      },\n      set: (_ref12, newValue) => {\n        let {\n          set: set\n        } = _ref12;\n        return set(base, newValue);\n      },\n      dangerouslyAllowMutability: options.dangerouslyAllowMutability\n    });\n  }({ ...restOptions,\n    default: optionsDefault\n  }) : function (options) {\n    const {\n      key: key,\n      persistence_UNSTABLE: persistence\n    } = options;\n    return registerNode$2({\n      key: key,\n      options: options,\n      get: (_store, state) => {\n        if (state.atomValues.has(key)) return [state, Recoil_nullthrows(state.atomValues.get(key))];\n\n        if (state.nonvalidatedAtoms.has(key)) {\n          if (null == persistence) return [state, loadableWithValue$2(options.default)];\n          const nonvalidatedValue = state.nonvalidatedAtoms.get(key),\n                validatedValue = persistence.validator(nonvalidatedValue, DEFAULT_VALUE$4);\n          return validatedValue instanceof DefaultValue$1 ? [{ ...state,\n            nonvalidatedAtoms: mapByDeletingFromMap$2(state.nonvalidatedAtoms, key)\n          }, loadableWithValue$2(options.default)] : [{ ...state,\n            atomValues: mapBySettingInMap$3(state.atomValues, key, loadableWithValue$2(validatedValue)),\n            nonvalidatedAtoms: mapByDeletingFromMap$2(state.nonvalidatedAtoms, key)\n          }, loadableWithValue$2(validatedValue)];\n        }\n\n        return [state, loadableWithValue$2(options.default)];\n      },\n      set: (_store, state, newValue) => (!0 !== options.dangerouslyAllowMutability && Recoil_deepFreezeValue(newValue), [{ ...state,\n        dirtyAtoms: setByAddingToSet$4(state.dirtyAtoms, key),\n        atomValues: newValue instanceof DefaultValue$1 ? mapByDeletingFromMap$2(state.atomValues, key) : mapBySettingInMap$3(state.atomValues, key, loadableWithValue$2(newValue)),\n        nonvalidatedAtoms: mapByDeletingFromMap$2(state.nonvalidatedAtoms, key)\n      }, new Set([key])])\n    });\n  }({ ...restOptions,\n    default: optionsDefault\n  });\n}\n\nvar Recoil_atom = atom;\n\nvar Recoil_stableStringify = function (x) {\n  let opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    allowFunctions: !1\n  };\n  return function stringify(x, opt, key) {\n    if (\"string\" == typeof x && !x.includes('\"') && !x.includes(\"\\\\\")) return \"\\\"\".concat(x, \"\\\"\");\n\n    switch (typeof x) {\n      case \"undefined\":\n        return \"\";\n\n      case \"boolean\":\n        return x ? \"true\" : \"false\";\n\n      case \"number\":\n      case \"symbol\":\n        return String(x);\n\n      case \"string\":\n        return JSON.stringify(x);\n\n      case \"function\":\n        if (!0 !== (null == opt ? void 0 : opt.allowFunctions)) throw new Error(\"Attempt to serialize function in a Recoil cache key\");\n        return \"__FUNCTION(\".concat(x.name, \")__\");\n    }\n\n    return null === x ? \"null\" : \"object\" != typeof x ? null !== (_JSON$stringify = JSON.stringify(x)) && void 0 !== _JSON$stringify ? _JSON$stringify : \"\" : Recoil_isPromise(x) ? \"__PROMISE__\" : Array.isArray(x) ? \"[\".concat(x.map((v, i) => stringify(v, opt, i.toString())), \"]\") : \"function\" == typeof x.toJSON ? stringify(x.toJSON(key), opt, key) : x instanceof Map ? stringify(Array.from(x).reduce((obj, _ref13) => {\n      let [k, v] = _ref13;\n      return { ...obj,\n        [\"string\" == typeof k ? k : stringify(k, opt)]: v\n      };\n    }, {}), opt, key) : x instanceof Set ? stringify(Array.from(x).sort((a, b) => stringify(a, opt).localeCompare(stringify(b, opt))), opt, key) : null != x[Symbol.iterator] && \"function\" == typeof x[Symbol.iterator] ? stringify(Array.from(x), opt, key) : \"{\".concat(Object.keys(x).filter(key => void 0 !== x[key]).sort().map(key => \"\".concat(stringify(key, opt), \":\").concat(stringify(x[key], opt, key))).join(\",\"), \"}\");\n\n    var _JSON$stringify;\n  }(x, opt);\n};\n\nvar Recoil_cacheWithValueEquality = function () {\n  const map = new Map(),\n        cache = {\n    get: key => map.get(Recoil_stableStringify(key)),\n    set: (key, value) => (map.set(Recoil_stableStringify(key), value), cache),\n    map: map\n  };\n  return cache;\n};\n\nlet nextIndex = 0;\n\nvar Recoil_selectorFamily = function (options) {\n  var _options$cacheImpleme, _options$cacheImpleme2;\n\n  let selectorCache = null !== (_options$cacheImpleme = null === (_options$cacheImpleme2 = options.cacheImplementationForParams_UNSTABLE) || void 0 === _options$cacheImpleme2 ? void 0 : _options$cacheImpleme2.call(options)) && void 0 !== _options$cacheImpleme ? _options$cacheImpleme : Recoil_cacheWithValueEquality();\n  return params => {\n    var _stableStringify, _options$cacheImpleme3;\n\n    const cachedSelector = selectorCache.get(params);\n    if (null != cachedSelector) return cachedSelector;\n\n    const myKey = \"\".concat(options.key, \"__selectorFamily/\").concat(null !== (_stableStringify = Recoil_stableStringify(params, {\n      allowFunctions: !0\n    })) && void 0 !== _stableStringify ? _stableStringify : \"void\", \"/\").concat(nextIndex++),\n          myGet = callbacks => options.get(params)(callbacks),\n          myCacheImplementation = null === (_options$cacheImpleme3 = options.cacheImplementation_UNSTABLE) || void 0 === _options$cacheImpleme3 ? void 0 : _options$cacheImpleme3.call(options);\n\n    let newSelector;\n\n    if (null != options.set) {\n      const set = options.set;\n      newSelector = Recoil_selector({\n        key: myKey,\n        get: myGet,\n        set: (callbacks, newValue) => set(params)(callbacks, newValue),\n        cacheImplementation_UNSTABLE: myCacheImplementation,\n        dangerouslyAllowMutability: options.dangerouslyAllowMutability\n      });\n    } else newSelector = Recoil_selector({\n      key: myKey,\n      get: myGet,\n      cacheImplementation_UNSTABLE: myCacheImplementation,\n      dangerouslyAllowMutability: options.dangerouslyAllowMutability\n    });\n\n    return selectorCache = selectorCache.set(params, newSelector), newSelector;\n  };\n},\n    ParameterizedAtomTaggedValue_DEPRECATED = getCjsExportFromNamespace(Object.freeze({\n  __proto__: null\n}));\n\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$5,\n  DefaultValue: DefaultValue$2\n} = Recoil_Node;\n\nfunction isSuperset(setA, setB) {\n  return Recoil_everySet(setB, b => setA.has(b));\n}\n\nconst pick = (object, chosenKeys) => Array.from(chosenKeys).reduce((obj, key) => ({ ...obj,\n  [key]: object[key]\n}), {});\n\nfunction mapPersistenceSettings_DEPRECATED(settings) {\n  if (null == settings) return;\n  const { ...passthrough\n  } = settings;\n  return { ...passthrough,\n    validator: storedValue => storedValue instanceof ParameterizedAtomTaggedValue_DEPRECATED ? new ParameterizedAtomTaggedValue_DEPRECATED(storedValue.value.filter(_ref14 => {\n      let [keys, map] = _ref14;\n      return keys instanceof Set && map instanceof Map;\n    }).map(_ref15 => {\n      let [keys, map] = _ref15;\n      return [keys, Array.from(map.entries()).reduce((acc, _ref16) => {\n        let [k, v] = _ref16;\n        const validatedValue = passthrough.validator(v, DEFAULT_VALUE$5);\n        return validatedValue instanceof DefaultValue$2 || acc.set(k, validatedValue), acc;\n      }, new Map())];\n    })) : passthrough.validator(storedValue, DEFAULT_VALUE$5)\n  };\n}\n\nvar Recoil_atomFamily = function (options) {\n  let atomCache = Recoil_cacheWithValueEquality();\n  const legacyAtomOptions = {\n    key: options.key,\n    default: DEFAULT_VALUE$5,\n    persistence_UNSTABLE: mapPersistenceSettings_DEPRECATED(options.persistence_UNSTABLE)\n  };\n  let legacyAtom;\n  legacyAtom = Recoil_atom(legacyAtomOptions);\n  const atomFamilyDefault = Recoil_selectorFamily({\n    key: options.key + \"__atomFamily/Default\",\n    get: param => _ref17 => {\n      let {\n        get: get\n      } = _ref17;\n      const legacyValue = get(\"function\" == typeof legacyAtom ? legacyAtom(param) : legacyAtom);\n\n      if (!(legacyValue instanceof DefaultValue$2)) {\n        const upgradedValue = function (baseValue, parameter) {\n          if (!(baseValue instanceof ParameterizedAtomTaggedValue_DEPRECATED)) return baseValue;\n          if (\"object\" != typeof parameter || null == parameter || Array.isArray(parameter)) return DEFAULT_VALUE$5;\n          const entries = baseValue.value,\n                parameterKeys = new Set(Object.keys(parameter));\n\n          for (const [entryParameterKeys, entryMap] of entries) if (isSuperset(parameterKeys, entryParameterKeys)) {\n            const contextOrSubcontext = parameterKeys.size === entryParameterKeys.size ? parameter : pick(parameter, entryParameterKeys),\n                  value = entryMap.get(Recoil_stableStringify(contextOrSubcontext));\n            if (void 0 !== value) return value;\n          }\n\n          return DEFAULT_VALUE$5;\n        }(legacyValue, param);\n\n        if (!(upgradedValue instanceof DefaultValue$2)) return upgradedValue;\n      }\n\n      return \"function\" == typeof options.default ? options.default(param) : options.default;\n    },\n    dangerouslyAllowMutability: options.dangerouslyAllowMutability\n  });\n  return params => {\n    var _stableStringify;\n\n    const cachedAtom = atomCache.get(params);\n    if (null != cachedAtom) return cachedAtom;\n    const newAtom = Recoil_atom({\n      key: \"\".concat(options.key, \"__\").concat(null !== (_stableStringify = Recoil_stableStringify(params)) && void 0 !== _stableStringify ? _stableStringify : \"void\"),\n      default: atomFamilyDefault(params),\n      persistence_UNSTABLE: options.persistence_UNSTABLE,\n      dangerouslyAllowMutability: options.dangerouslyAllowMutability\n    });\n    return atomCache = atomCache.set(params, newAtom), newAtom;\n  };\n};\n\nconst constantSelector = Recoil_selectorFamily({\n  key: \"__constant\",\n  get: constant => () => constant,\n  cacheImplementationForParams_UNSTABLE: Recoil_cacheWithReferenceEquality\n});\n\nvar Recoil_constSelector = function (constant) {\n  return constantSelector(constant);\n};\n\nconst throwingSelector = Recoil_selectorFamily({\n  key: \"__error\",\n  get: message => () => {\n    throw new Error(message);\n  },\n  cacheImplementationForParams_UNSTABLE: Recoil_cacheWithReferenceEquality\n});\n\nvar Recoil_errorSelector = function (message) {\n  return throwingSelector(message);\n};\n\nvar Recoil_readOnlySelector = function (atom) {\n  return atom;\n};\n\nconst {\n  loadableWithError: loadableWithError$2,\n  loadableWithPromise: loadableWithPromise$2,\n  loadableWithValue: loadableWithValue$3\n} = Recoil_Loadable;\n\nfunction concurrentRequests(getRecoilValue, deps) {\n  const results = Array(deps.length).fill(void 0),\n        exceptions = Array(deps.length).fill(void 0);\n\n  for (const [i, dep] of deps.entries()) try {\n    results[i] = getRecoilValue(dep);\n  } catch (e) {\n    exceptions[i] = e;\n  }\n\n  return [results, exceptions];\n}\n\nfunction isError(exp) {\n  return null != exp && !Recoil_isPromise(exp);\n}\n\nfunction unwrapDependencies(dependencies) {\n  return Array.isArray(dependencies) ? dependencies : Object.getOwnPropertyNames(dependencies).map(key => dependencies[key]);\n}\n\nfunction wrapResults(dependencies, results) {\n  return Array.isArray(dependencies) ? results : Object.getOwnPropertyNames(dependencies).reduce((out, key, idx) => ({ ...out,\n    [key]: results[idx]\n  }), {});\n}\n\nfunction wrapLoadables(dependencies, results, exceptions) {\n  return wrapResults(dependencies, exceptions.map((exception, idx) => null == exception ? loadableWithValue$3(results[idx]) : Recoil_isPromise(exception) ? loadableWithPromise$2(exception) : loadableWithError$2(exception)));\n}\n\nvar Recoil_WaitFor = {\n  waitForNone: Recoil_selectorFamily({\n    key: \"__waitForNone\",\n    get: dependencies => _ref18 => {\n      let {\n        get: get\n      } = _ref18;\n      const deps = unwrapDependencies(dependencies),\n            [results, exceptions] = concurrentRequests(get, deps);\n      return wrapLoadables(dependencies, results, exceptions);\n    }\n  }),\n  waitForAny: Recoil_selectorFamily({\n    key: \"__waitForAny\",\n    get: dependencies => _ref19 => {\n      let {\n        get: get\n      } = _ref19;\n      const deps = unwrapDependencies(dependencies),\n            [results, exceptions] = concurrentRequests(get, deps);\n      if (exceptions.some(exp => null == exp)) return wrapLoadables(dependencies, results, exceptions);\n      if (exceptions.every(isError)) throw exceptions.find(isError);\n      throw new Promise((resolve, reject) => {\n        for (const [i, exp] of exceptions.entries()) Recoil_isPromise(exp) && exp.then(result => {\n          results[i] = result, exceptions[i] = null, resolve(wrapLoadables(dependencies, results, exceptions));\n        }).catch(error => {\n          exceptions[i] = error, exceptions.every(isError) && reject(exceptions[0]);\n        });\n      });\n    }\n  }),\n  waitForAll: Recoil_selectorFamily({\n    key: \"__waitForAll\",\n    get: dependencies => _ref20 => {\n      let {\n        get: get\n      } = _ref20;\n      const deps = unwrapDependencies(dependencies),\n            [results, exceptions] = concurrentRequests(get, deps);\n      if (exceptions.every(exp => null == exp)) return wrapResults(dependencies, results);\n      const error = exceptions.find(isError);\n      if (null != error) throw error;\n      throw Promise.all(exceptions).then(results => wrapResults(dependencies, results));\n    }\n  }),\n  noWait: Recoil_selectorFamily({\n    key: \"__noWait\",\n    get: dependency => _ref21 => {\n      let {\n        get: get\n      } = _ref21;\n\n      try {\n        return loadableWithValue$3(get(dependency));\n      } catch (exception) {\n        return Recoil_isPromise(exception) ? loadableWithPromise$2(exception) : loadableWithError$2(exception);\n      }\n    }\n  })\n};\nconst {\n  DefaultValue: DefaultValue$3\n} = Recoil_Node,\n      {\n  RecoilRoot: RecoilRoot$1\n} = Recoil_RecoilRoot_react,\n      {\n  isRecoilValue: isRecoilValue$3\n} = require$$2,\n      {\n  useGotoRecoilSnapshot: useGotoRecoilSnapshot$1,\n  useRecoilCallback: useRecoilCallback$1,\n  useRecoilSnapshot: useRecoilSnapshot$1,\n  useRecoilState: useRecoilState$1,\n  useRecoilStateLoadable: useRecoilStateLoadable$1,\n  useRecoilTransactionObserver: useRecoilTransactionObserver$1,\n  useRecoilValue: useRecoilValue$1,\n  useRecoilValueLoadable: useRecoilValueLoadable$1,\n  useResetRecoilState: useResetRecoilState$1,\n  useSetRecoilState: useSetRecoilState$1,\n  useSetUnvalidatedAtomValues: useSetUnvalidatedAtomValues$1,\n  useTransactionObservation_DEPRECATED: useTransactionObservation_DEPRECATED$1\n} = Recoil_Hooks,\n      {\n  noWait: noWait$1,\n  waitForAll: waitForAll$1,\n  waitForAny: waitForAny$1,\n  waitForNone: waitForNone$1\n} = Recoil_WaitFor;\nvar Recoil_index = {\n  DefaultValue: DefaultValue$3,\n  RecoilRoot: RecoilRoot$1,\n  atom: Recoil_atom,\n  selector: Recoil_selector,\n  atomFamily: Recoil_atomFamily,\n  selectorFamily: Recoil_selectorFamily,\n  constSelector: Recoil_constSelector,\n  errorSelector: Recoil_errorSelector,\n  readOnlySelector: Recoil_readOnlySelector,\n  useRecoilValue: useRecoilValue$1,\n  useRecoilValueLoadable: useRecoilValueLoadable$1,\n  useRecoilState: useRecoilState$1,\n  useRecoilStateLoadable: useRecoilStateLoadable$1,\n  useSetRecoilState: useSetRecoilState$1,\n  useResetRecoilState: useResetRecoilState$1,\n  useRecoilCallback: useRecoilCallback$1,\n  useGotoRecoilSnapshot: useGotoRecoilSnapshot$1,\n  useRecoilSnapshot: useRecoilSnapshot$1,\n  useRecoilTransactionObserver_UNSTABLE: useRecoilTransactionObserver$1,\n  useTransactionObservation_UNSTABLE: useTransactionObservation_DEPRECATED$1,\n  useSetUnvalidatedAtomValues_UNSTABLE: useSetUnvalidatedAtomValues$1,\n  noWait: noWait$1,\n  waitForNone: waitForNone$1,\n  waitForAny: waitForAny$1,\n  waitForAll: waitForAll$1,\n  isRecoilValue: isRecoilValue$3\n},\n    Recoil_index_1 = Recoil_index.DefaultValue,\n    Recoil_index_2 = Recoil_index.RecoilRoot,\n    Recoil_index_3 = Recoil_index.atom,\n    Recoil_index_4 = Recoil_index.selector,\n    Recoil_index_5 = Recoil_index.atomFamily,\n    Recoil_index_6 = Recoil_index.selectorFamily,\n    Recoil_index_7 = Recoil_index.constSelector,\n    Recoil_index_8 = Recoil_index.errorSelector,\n    Recoil_index_9 = Recoil_index.readOnlySelector,\n    Recoil_index_10 = Recoil_index.useRecoilValue,\n    Recoil_index_11 = Recoil_index.useRecoilValueLoadable,\n    Recoil_index_12 = Recoil_index.useRecoilState,\n    Recoil_index_13 = Recoil_index.useRecoilStateLoadable,\n    Recoil_index_14 = Recoil_index.useSetRecoilState,\n    Recoil_index_15 = Recoil_index.useResetRecoilState,\n    Recoil_index_16 = Recoil_index.useRecoilCallback,\n    Recoil_index_17 = Recoil_index.useGotoRecoilSnapshot,\n    Recoil_index_18 = Recoil_index.useRecoilSnapshot,\n    Recoil_index_19 = Recoil_index.useRecoilTransactionObserver_UNSTABLE,\n    Recoil_index_20 = Recoil_index.useTransactionObservation_UNSTABLE,\n    Recoil_index_21 = Recoil_index.useSetUnvalidatedAtomValues_UNSTABLE,\n    Recoil_index_22 = Recoil_index.noWait,\n    Recoil_index_23 = Recoil_index.waitForNone,\n    Recoil_index_24 = Recoil_index.waitForAny,\n    Recoil_index_25 = Recoil_index.waitForAll,\n    Recoil_index_26 = Recoil_index.isRecoilValue;\nexports.DefaultValue = Recoil_index_1, exports.RecoilRoot = Recoil_index_2, exports.atom = Recoil_index_3, exports.atomFamily = Recoil_index_5, exports.constSelector = Recoil_index_7, exports.default = Recoil_index, exports.errorSelector = Recoil_index_8, exports.isRecoilValue = Recoil_index_26, exports.noWait = Recoil_index_22, exports.readOnlySelector = Recoil_index_9, exports.selector = Recoil_index_4, exports.selectorFamily = Recoil_index_6, exports.useGotoRecoilSnapshot = Recoil_index_17, exports.useRecoilCallback = Recoil_index_16, exports.useRecoilSnapshot = Recoil_index_18, exports.useRecoilState = Recoil_index_12, exports.useRecoilStateLoadable = Recoil_index_13, exports.useRecoilTransactionObserver_UNSTABLE = Recoil_index_19, exports.useRecoilValue = Recoil_index_10, exports.useRecoilValueLoadable = Recoil_index_11, exports.useResetRecoilState = Recoil_index_15, exports.useSetRecoilState = Recoil_index_14, exports.useSetUnvalidatedAtomValues_UNSTABLE = Recoil_index_21, exports.useTransactionObservation_UNSTABLE = Recoil_index_20, exports.waitForAll = Recoil_index_25, exports.waitForAny = Recoil_index_24, exports.waitForNone = Recoil_index_23;","map":{"version":3,"sources":["/home/kali/Documents/cybersecurity-bounty-hunting-platform/client/node_modules/recoil/dist/recoil.production.js"],"names":["_interopDefault","ex","default","Object","defineProperty","exports","value","react","require","reactDom","_defineProperty","obj","key","enumerable","configurable","writable","AbstractRecoilValue","constructor","newKey","RecoilState","RecoilValueReadOnly","Recoil_RecoilValue","isRecoilValue","x","Recoil_RecoilValue_1","Recoil_RecoilValue_2","Recoil_RecoilValue_3","Recoil_RecoilValue_4","getCjsExportFromNamespace","n","require$$2","freeze","__proto__","DefaultValue","DEFAULT_VALUE","RecoilValueNotReady","Error","nodes","Map","NodeMissingError","Recoil_Node","registerNode","node","has","set","getNode","get","Recoil_Queue","enqueueExecution","s","f","Recoil_CopyOnWrite","setByAddingToSet","v","next","Set","add","setByDeletingFromSet","delete","mapBySettingInMap","map","k","mapByUpdatingInMap","updater","mapByDeletingFromMap","Recoil_Tracing","trace","message","fn","wrap","mapByDeletingFromMap$1","mapBySettingInMap$1","mapByUpdatingInMap$1","setByAddingToSet$1","getNode$1","emptyMap","emptySet","ReadOnlyRecoilValueError","getNodeLoadable","store","state","subscriptionID","Recoil_FunctionalCore","peekNodeLoadable","setNodeValue","newValue","newState","writtenNodes","setUnvalidatedAtomValue","atomValues","nonvalidatedAtoms","dirtyAtoms","subscribeComponentToNode","callback","subID","nodeToComponentSubscriptions","subsForAtom","fireNodeSubscriptions","updatedNodes","when","_store$getState$nextT","getState","nextTree","currentTree","dependentNodes","keys","visitedNodes","visitingNodes","Array","from","pop","_state$nodeToNodeSubs","subscribedNodes","nodeToNodeSubscriptions","downstreamNode","push","_state$nodeToComponen","forEach","_debugName","cb","queuedComponentCallbacks","join","resolvers","suspendedComponentResolvers","r","clear","detectCircularDependencies","stack","length","leaf","downstream","size","root","reverse","Recoil_mapMap","result","getNodeLoadable$1","peekNodeLoadable$1","setNodeValue$1","setUnvalidatedAtomValue$1","subscribeComponentToNode$1","RecoilValueNotReady$1","AbstractRecoilValue$1","RecoilState$1","RecoilValueReadOnly$1","Recoil_RecoilValueInterface","valueFromValueOrUpdater","valueOrUpdater","_storeState$nextTree","storeState","current","contents","getRecoilValueAsLoadable","replaceState","loadable","setRecoilValue","setUnvalidatedRecoilValue","subscribeToRecoilValue","releaseFn","release","makeEmptyTreeState","transactionMetadata","nodeDeps","makeStoreState","treeState","transactionSubscriptions","Recoil_State","makeEmptyStoreState","DEFAULT_VALUE$1","getRecoilValueAsLoadable$1","setRecoilValue$1","valueFromValueOrUpdater$1","makeEmptyTreeState$1","makeStoreState$1","Snapshot","recoilValue","_store","getLoadable","toPromise","mapper","mutableSnapshot","MutableSnapshot","cloneSnapshot","getStore_INTERNAL","replacer","subscribeToTransactions","addTransactionMetadata","cloneTreeState","recoilState","newValueOrUpdater","Recoil_Snapshot","freshSnapshot","Recoil_Snapshot_1","Recoil_Snapshot_2","Recoil_Snapshot_3","Recoil_Snapshot_4","Recoil_nullthrows","require$$6","useContext","useEffect","useRef","useState","fireNodeSubscriptions$1","setNodeValue$2","setUnvalidatedAtomValue$2","freshSnapshot$1","makeEmptyStoreState$1","makeStoreState$2","notInAContext","defaultStore","startNextTreeIfNeeded","AppContext","createContext","useStoreRef","Batcher","props","storeRef","_","setState","setNotifyBatcherOfChange","sub","splice","nextID","Recoil_RecoilRoot_react","RecoilRoot","initializeState_DEPRECATED","initializeState","children","notifyBatcherOfChange","replaced","id","metadata","initial","atom","setUnvalidatedAtomValues","snapshot","createElement","Provider","Recoil_differenceSets","ret","setsWithValuesToRemove","FIRST","otherSet","Recoil_filterMap","Recoil_intersectSets","first","rest","Recoil_invariant","condition","Recoil_mergeMaps","maps","i","iterator","nextKey","done","useCallback","useEffect$1","useMemo","useRef$1","useState$1","peekNodeLoadable$2","setNodeValue$3","DEFAULT_VALUE$2","getNode$2","nodes$1","useStoreRef$1","AbstractRecoilValue$2","getRecoilValueAsLoadable$2","setRecoilValue$2","setUnvalidatedRecoilValue$1","subscribeToRecoilValue$1","valueFromValueOrUpdater$2","Snapshot$1","cloneSnapshot$1","setByAddingToSet$2","useInterface","forceUpdate","recoilValuesUsed","previousSubscriptions","subscriptions","unsubscribeFrom","updateState","_state","subs","useSetRecoilState","useRecoilValueLoadable","useRecoilValue","Promise","resolve","getRecoilValue","getRecoilValueLoadable","getRecoilState","getRecoilStateLoadable","getSetRecoilState","getResetRecoilState","useTransactionSubscription","useTreeStateClone_DEPRECATED","subsByAtom","externallyVisibleAtomValuesInState","persistedAtomContentsValues","_node$options","persistence","options","persistence_UNSTABLE","type","useGotoRecoilSnapshot","unstable_batchedUpdates","prevState","nextState","updatedKeys","_prevState$atomValues","_nextState$atomValues","Sentinel","SENTINEL","Recoil_Hooks","useRecoilCallback","deps","gotoSnapshot","args","reset","useRecoilState","recoilInterface","useRecoilStateLoadable","useResetRecoilState","useRecoilInterface","useSnapshotWithStateChange_DEPRECATED","transaction","updatedAtoms","useTransactionSubscription_DEPRECATED","useTransactionObservation_DEPRECATED","previousState","previousAtomValues","atomInfo","_node$options$persist","_node$options2","_node$options2$persis","_node$options$persist2","_node$options3","_node$options3$persis","backButton","modifiedAtoms","useRecoilTransactionObserver","previousSnapshot","useRecoilSnapshot","setSnapshot","useGoToSnapshot_DEPRECATED","useSetUnvalidatedAtomValues","values","Recoil_isPromise","p","then","loadableAccessors","getValue","reject","valueMaybe","valueOrThrow","errorMaybe","errorOrThrow","promiseMaybe","promiseOrThrow","loadableWithPromise","loadableWithValue","e","loadableWithError","catch","error","promise","Recoil_Loadable","loadableLoading","loadableAll","inputs","every","some","find","all","Recoil_isNode","object","_ownerDocument","_doc$defaultView","window","defaultView","ownerDocument","document","Node","nodeType","nodeName","Recoil_deepFreezeValue","deepFreezeValue","$$typeof","prototype","hasOwnProperty","call","prop","isFrozen","seal","LEAF","Symbol","emptyMap$1","ArrayKeyedMap","existing","_base","entries","ks","isArray","_map$get","answer","recurse","level","prefix","concat","toBuiltInMap","Recoil_ArrayKeyedMap","Recoil_cacheWithReferenceEquality","Recoil_everySet","context","entry","Recoil_equalsSet","one","two","Recoil_PerformanceTimings","startPerfBlock","_id","mapBySettingInMap$2","mapByUpdatingInMap$2","setByAddingToSet$3","setByDeletingFromSet$1","detectCircularDependencies$1","getNodeLoadable$2","setNodeValue$4","loadableWithError$1","loadableWithPromise$1","loadableWithValue$1","DEFAULT_VALUE$3","RecoilValueNotReady$2","registerNode$1","startPerfBlock$1","isRecoilValue$1","emptySet$2","cacheKeyFromDepValues","depValues","sort","Recoil_selector","cacheImplementation_UNSTABLE","cacheImplementation","cache","getFromCache","_state$nodeDeps$get","currentDeps","cacheKey","depKey","cached","newDepValues","_state$nodeDeps$get2","newStateFromEvaluate","endPerfBlock","output","finally","errorOrDepPromise","asyncState","newAsyncState","oldDeps","newDeps","addedDeps","removedDeps","upstreamNode","newCacheKey","dangerouslyAllowMutability","myGet","setRecoilState","written","loadableWithValue$2","DEFAULT_VALUE$4","DefaultValue$1","registerNode$2","isRecoilValue$2","mapByDeletingFromMap$2","mapBySettingInMap$3","setByAddingToSet$4","optionsDefault","restOptions","base","validator","storedValue","baseValue","nonvalidatedValue","validatedValue","Recoil_atom","Recoil_stableStringify","opt","allowFunctions","stringify","includes","String","JSON","name","_JSON$stringify","toString","toJSON","reduce","a","b","localeCompare","filter","Recoil_cacheWithValueEquality","nextIndex","Recoil_selectorFamily","_options$cacheImpleme","_options$cacheImpleme2","selectorCache","cacheImplementationForParams_UNSTABLE","params","_stableStringify","_options$cacheImpleme3","cachedSelector","myKey","callbacks","myCacheImplementation","newSelector","ParameterizedAtomTaggedValue_DEPRECATED","DEFAULT_VALUE$5","DefaultValue$2","isSuperset","setA","setB","pick","chosenKeys","mapPersistenceSettings_DEPRECATED","settings","passthrough","acc","Recoil_atomFamily","atomCache","legacyAtomOptions","legacyAtom","atomFamilyDefault","param","legacyValue","upgradedValue","parameter","parameterKeys","entryParameterKeys","entryMap","contextOrSubcontext","cachedAtom","newAtom","constantSelector","constant","Recoil_constSelector","throwingSelector","Recoil_errorSelector","Recoil_readOnlySelector","loadableWithError$2","loadableWithPromise$2","loadableWithValue$3","concurrentRequests","results","fill","exceptions","dep","isError","exp","unwrapDependencies","dependencies","getOwnPropertyNames","wrapResults","out","idx","wrapLoadables","exception","Recoil_WaitFor","waitForNone","waitForAny","waitForAll","noWait","dependency","DefaultValue$3","RecoilRoot$1","isRecoilValue$3","useGotoRecoilSnapshot$1","useRecoilCallback$1","useRecoilSnapshot$1","useRecoilState$1","useRecoilStateLoadable$1","useRecoilTransactionObserver$1","useRecoilValue$1","useRecoilValueLoadable$1","useResetRecoilState$1","useSetRecoilState$1","useSetUnvalidatedAtomValues$1","useTransactionObservation_DEPRECATED$1","noWait$1","waitForAll$1","waitForAny$1","waitForNone$1","Recoil_index","selector","atomFamily","selectorFamily","constSelector","errorSelector","readOnlySelector","useRecoilTransactionObserver_UNSTABLE","useTransactionObservation_UNSTABLE","useSetUnvalidatedAtomValues_UNSTABLE","Recoil_index_1","Recoil_index_2","Recoil_index_3","Recoil_index_4","Recoil_index_5","Recoil_index_6","Recoil_index_7","Recoil_index_8","Recoil_index_9","Recoil_index_10","Recoil_index_11","Recoil_index_12","Recoil_index_13","Recoil_index_14","Recoil_index_15","Recoil_index_16","Recoil_index_17","Recoil_index_18","Recoil_index_19","Recoil_index_20","Recoil_index_21","Recoil_index_22","Recoil_index_23","Recoil_index_24","Recoil_index_25","Recoil_index_26"],"mappings":"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","sourcesContent":["\"use strict\";function _interopDefault(ex){return ex&&\"object\"==typeof ex&&\"default\"in ex?ex.default:ex}Object.defineProperty(exports,\"__esModule\",{value:!0});var react=_interopDefault(require(\"react\")),reactDom=_interopDefault(require(\"react-dom\"));function _defineProperty(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}class AbstractRecoilValue{constructor(newKey){_defineProperty(this,\"key\",void 0),this.key=newKey}}class RecoilState extends AbstractRecoilValue{}class RecoilValueReadOnly extends AbstractRecoilValue{}var Recoil_RecoilValue={AbstractRecoilValue:AbstractRecoilValue,RecoilState:RecoilState,RecoilValueReadOnly:RecoilValueReadOnly,isRecoilValue:function(x){return x instanceof RecoilState||x instanceof RecoilValueReadOnly}},Recoil_RecoilValue_1=Recoil_RecoilValue.AbstractRecoilValue,Recoil_RecoilValue_2=Recoil_RecoilValue.RecoilState,Recoil_RecoilValue_3=Recoil_RecoilValue.RecoilValueReadOnly,Recoil_RecoilValue_4=Recoil_RecoilValue.isRecoilValue;function getCjsExportFromNamespace(n){return n&&n.default||n}var require$$2=getCjsExportFromNamespace(Object.freeze({__proto__:null,AbstractRecoilValue:Recoil_RecoilValue_1,RecoilState:Recoil_RecoilValue_2,RecoilValueReadOnly:Recoil_RecoilValue_3,isRecoilValue:Recoil_RecoilValue_4}));class DefaultValue{}const DEFAULT_VALUE=new DefaultValue;class RecoilValueNotReady extends Error{constructor(key){super(`Tried to set the value of Recoil selector ${key} using an updater function, but it is an async selector in a pending or error state; this is not supported.`)}}const nodes=new Map;class NodeMissingError extends Error{}var Recoil_Node={nodes:nodes,registerNode:function(node){if(nodes.has(node.key)){node.key}return nodes.set(node.key,node),null==node.set?new require$$2.RecoilValueReadOnly(node.key):new require$$2.RecoilState(node.key)},getNode:function(key){const node=nodes.get(key);if(null==node)throw new NodeMissingError(`Missing definition for RecoilValue: \"${key}\"\"`);return node},NodeMissingError:NodeMissingError,DefaultValue:DefaultValue,DEFAULT_VALUE:DEFAULT_VALUE,RecoilValueNotReady:RecoilValueNotReady};var Recoil_Queue={enqueueExecution:function(s,f){f()}};var Recoil_CopyOnWrite={setByAddingToSet:function(set,v){const next=new Set(set);return next.add(v),next},setByDeletingFromSet:function(set,v){const next=new Set(set);return next.delete(v),next},mapBySettingInMap:function(map,k,v){const next=new Map(map);return next.set(k,v),next},mapByUpdatingInMap:function(map,k,updater){const next=new Map(map);return next.set(k,updater(next.get(k))),next},mapByDeletingFromMap:function(map,k){const next=new Map(map);return next.delete(k),next}};var Recoil_Tracing={trace:function(message,node,fn){return fn()},wrap:function(fn){return fn}};const{mapByDeletingFromMap:mapByDeletingFromMap$1,mapBySettingInMap:mapBySettingInMap$1,mapByUpdatingInMap:mapByUpdatingInMap$1,setByAddingToSet:setByAddingToSet$1}=Recoil_CopyOnWrite,{getNode:getNode$1}=Recoil_Node,emptyMap=Object.freeze(new Map),emptySet=Object.freeze(new Set);class ReadOnlyRecoilValueError extends Error{}function getNodeLoadable(store,state,key){return getNode$1(key).get(store,state)}let subscriptionID=0;var Recoil_FunctionalCore={getNodeLoadable:getNodeLoadable,peekNodeLoadable:function(store,state,key){return getNodeLoadable(store,state,key)[1]},setNodeValue:function(store,state,key,newValue){const node=getNode$1(key);if(null==node.set)throw new ReadOnlyRecoilValueError(\"Attempt to set read-only RecoilValue: \"+key);const[newState,writtenNodes]=node.set(store,state,newValue);return[newState,writtenNodes]},setUnvalidatedAtomValue:function(state,key,newValue){return{...state,atomValues:mapByDeletingFromMap$1(state.atomValues,key),nonvalidatedAtoms:mapBySettingInMap$1(state.nonvalidatedAtoms,key,newValue),dirtyAtoms:setByAddingToSet$1(state.dirtyAtoms,key)}},subscribeComponentToNode:function(state,key,callback){const subID=subscriptionID++;return[{...state,nodeToComponentSubscriptions:mapByUpdatingInMap$1(state.nodeToComponentSubscriptions,key,subsForAtom=>mapBySettingInMap$1(null!=subsForAtom?subsForAtom:emptyMap,subID,[\"TODO debug name\",callback]))},function(state){return{...state,nodeToComponentSubscriptions:mapByUpdatingInMap$1(state.nodeToComponentSubscriptions,key,subsForAtom=>mapByDeletingFromMap$1(null!=subsForAtom?subsForAtom:emptyMap,subID))}}]},fireNodeSubscriptions:function(store,updatedNodes,when){var _store$getState$nextT;const state=\"enqueue\"===when&&null!==(_store$getState$nextT=store.getState().nextTree)&&void 0!==_store$getState$nextT?_store$getState$nextT:store.getState().currentTree,dependentNodes=function(state,keys){const dependentNodes=new Set,visitedNodes=new Set,visitingNodes=Array.from(keys);for(let key=visitingNodes.pop();key;key=visitingNodes.pop()){var _state$nodeToNodeSubs;dependentNodes.add(key),visitedNodes.add(key);const subscribedNodes=null!==(_state$nodeToNodeSubs=state.nodeToNodeSubscriptions.get(key))&&void 0!==_state$nodeToNodeSubs?_state$nodeToNodeSubs:emptySet;for(const downstreamNode of subscribedNodes)visitedNodes.has(downstreamNode)||visitingNodes.push(downstreamNode)}return dependentNodes}(state,updatedNodes);for(const key of dependentNodes){var _state$nodeToComponen;(null!==(_state$nodeToComponen=state.nodeToComponentSubscriptions.get(key))&&void 0!==_state$nodeToComponen?_state$nodeToComponen:[]).forEach(([_debugName,cb])=>{\"enqueue\"===when?store.getState().queuedComponentCallbacks.push(cb):cb(state)})}Recoil_Tracing.trace(\"value became available, waking components\",Array.from(updatedNodes).join(\", \"),()=>{const resolvers=store.getState().suspendedComponentResolvers;resolvers.forEach(r=>r()),resolvers.clear()})},detectCircularDependencies:function detectCircularDependencies(state,stack){if(!stack.length)return;const leaf=stack[stack.length-1],downstream=state.nodeToNodeSubscriptions.get(leaf);if(!(null==downstream?void 0:downstream.size))return;const root=stack[0];if(downstream.has(root))throw new Error(\"Recoil selector has circular dependencies: \"+[...stack,root].reverse().join(\" â†’ \"));for(const next of downstream)detectCircularDependencies(state,[...stack,next])}};var Recoil_mapMap=function(map,callback){const result=new Map;return map.forEach((value,key)=>{result.set(key,callback(value,key))}),result};const{getNodeLoadable:getNodeLoadable$1,peekNodeLoadable:peekNodeLoadable$1,setNodeValue:setNodeValue$1,setUnvalidatedAtomValue:setUnvalidatedAtomValue$1,subscribeComponentToNode:subscribeComponentToNode$1}=Recoil_FunctionalCore,{RecoilValueNotReady:RecoilValueNotReady$1}=Recoil_Node,{AbstractRecoilValue:AbstractRecoilValue$1,RecoilState:RecoilState$1,RecoilValueReadOnly:RecoilValueReadOnly$1}=require$$2;var Recoil_RecoilValueInterface={RecoilValueReadOnly:RecoilValueReadOnly$1,AbstractRecoilValue:AbstractRecoilValue$1,RecoilState:RecoilState$1,valueFromValueOrUpdater:function(store,{key:key},valueOrUpdater){if(\"function\"==typeof valueOrUpdater){var _storeState$nextTree;const storeState=store.getState(),state=null!==(_storeState$nextTree=storeState.nextTree)&&void 0!==_storeState$nextTree?_storeState$nextTree:storeState.currentTree,current=peekNodeLoadable$1(store,state,key);if(\"loading\"===current.state)throw new RecoilValueNotReady$1(key);if(\"hasError\"===current.state)throw current.contents;return valueOrUpdater(current.contents)}return valueOrUpdater},getRecoilValueAsLoadable:function(store,{key:key}){let result;return Recoil_Tracing.trace(\"get RecoilValue\",key,()=>store.replaceState(Recoil_Tracing.wrap(state=>{const[newState,loadable]=getNodeLoadable$1(store,state,key);return result=loadable,newState}))),result},setRecoilValue:function(store,{key:key},newValue){Recoil_Tracing.trace(\"set RecoilValue\",key,()=>store.replaceState(Recoil_Tracing.wrap(state=>{const[newState,writtenNodes]=setNodeValue$1(store,state,key,newValue);return store.fireNodeSubscriptions(writtenNodes,\"enqueue\"),newState})))},setUnvalidatedRecoilValue:function(store,{key:key},newValue){Recoil_Tracing.trace(\"set unvalidated persisted atom\",key,()=>store.replaceState(Recoil_Tracing.wrap(state=>{const newState=setUnvalidatedAtomValue$1(state,key,newValue);return store.fireNodeSubscriptions(new Set([key]),\"enqueue\"),newState})))},subscribeToRecoilValue:function(store,{key:key},callback){let newState,releaseFn;return Recoil_Tracing.trace(\"subscribe component to RecoilValue\",key,()=>store.replaceState(Recoil_Tracing.wrap(state=>([newState,releaseFn]=subscribeComponentToNode$1(state,key,callback),newState)))),{release:store=>store.replaceState(releaseFn)}}};function makeEmptyTreeState(){return{transactionMetadata:{},atomValues:new Map,nonvalidatedAtoms:new Map,dirtyAtoms:new Set,nodeDeps:new Map,nodeToNodeSubscriptions:new Map,nodeToComponentSubscriptions:new Map}}function makeStoreState(treeState){return{currentTree:treeState,nextTree:null,transactionSubscriptions:new Map,queuedComponentCallbacks:[],suspendedComponentResolvers:new Set}}var Recoil_State={makeEmptyTreeState:makeEmptyTreeState,makeEmptyStoreState:function(){return makeStoreState(makeEmptyTreeState())},makeStoreState:makeStoreState};const{DEFAULT_VALUE:DEFAULT_VALUE$1}=Recoil_Node,{getRecoilValueAsLoadable:getRecoilValueAsLoadable$1,setRecoilValue:setRecoilValue$1,valueFromValueOrUpdater:valueFromValueOrUpdater$1}=Recoil_RecoilValueInterface,{makeEmptyTreeState:makeEmptyTreeState$1,makeStoreState:makeStoreState$1}=Recoil_State;class Snapshot{constructor(treeState){_defineProperty(this,\"_store\",void 0),_defineProperty(this,\"getLoadable\",recoilValue=>getRecoilValueAsLoadable$1(this._store,recoilValue)),_defineProperty(this,\"getPromise\",recoilValue=>this.getLoadable(recoilValue).toPromise()),_defineProperty(this,\"map\",mapper=>{const mutableSnapshot=new MutableSnapshot(this._store.getState().currentTree);mapper(mutableSnapshot);return cloneSnapshot(mutableSnapshot.getStore_INTERNAL().getState().currentTree)}),_defineProperty(this,\"asyncMap\",async mapper=>{const mutableSnapshot=new MutableSnapshot(this._store.getState().currentTree);await mapper(mutableSnapshot);return cloneSnapshot(mutableSnapshot.getStore_INTERNAL().getState().currentTree)}),this._store=function(treeState){const storeState=makeStoreState$1(treeState);return{getState:()=>storeState,replaceState:replacer=>{storeState.currentTree=replacer(storeState.currentTree)},subscribeToTransactions:()=>{throw new Error(\"Cannot subscribe to Snapshots\")},addTransactionMetadata:()=>{throw new Error(\"Cannot subscribe to Snapshots\")},fireNodeSubscriptions:()=>{}}}(treeState)}getStore_INTERNAL(){return this._store}}function cloneTreeState(treeState){return{transactionMetadata:{...treeState.transactionMetadata},atomValues:new Map(treeState.atomValues),nonvalidatedAtoms:new Map(treeState.nonvalidatedAtoms),dirtyAtoms:new Set(treeState.dirtyAtoms),nodeDeps:new Map(treeState.nodeDeps),nodeToNodeSubscriptions:Recoil_mapMap(treeState.nodeToNodeSubscriptions,keys=>new Set(keys)),nodeToComponentSubscriptions:new Map}}function cloneSnapshot(treeState){return new Snapshot(cloneTreeState(treeState))}class MutableSnapshot extends Snapshot{constructor(treeState){super(cloneTreeState(treeState)),_defineProperty(this,\"set\",(recoilState,newValueOrUpdater)=>{const store=this.getStore_INTERNAL(),newValue=valueFromValueOrUpdater$1(store,recoilState,newValueOrUpdater);setRecoilValue$1(store,recoilState,newValue)}),_defineProperty(this,\"reset\",recoilState=>setRecoilValue$1(this.getStore_INTERNAL(),recoilState,DEFAULT_VALUE$1))}}var Recoil_Snapshot={Snapshot:Snapshot,MutableSnapshot:MutableSnapshot,freshSnapshot:function(){return new Snapshot(makeEmptyTreeState$1())},cloneSnapshot:cloneSnapshot},Recoil_Snapshot_1=Recoil_Snapshot.Snapshot,Recoil_Snapshot_2=Recoil_Snapshot.MutableSnapshot,Recoil_Snapshot_3=Recoil_Snapshot.freshSnapshot,Recoil_Snapshot_4=Recoil_Snapshot.cloneSnapshot;var Recoil_nullthrows=function(x,message){if(null!=x)return x;throw new Error(null!=message?message:\"Got unexpected null or undefined\")},require$$6=getCjsExportFromNamespace(Object.freeze({__proto__:null,Snapshot:Recoil_Snapshot_1,MutableSnapshot:Recoil_Snapshot_2,freshSnapshot:Recoil_Snapshot_3,cloneSnapshot:Recoil_Snapshot_4}));const{useContext:useContext,useEffect:useEffect,useRef:useRef,useState:useState}=react,{fireNodeSubscriptions:fireNodeSubscriptions$1,setNodeValue:setNodeValue$2,setUnvalidatedAtomValue:setUnvalidatedAtomValue$2}=Recoil_FunctionalCore,{freshSnapshot:freshSnapshot$1}=require$$6,{makeEmptyStoreState:makeEmptyStoreState$1,makeStoreState:makeStoreState$2}=Recoil_State;function notInAContext(){throw new Error(\"This component must be used inside a <RecoilRoot> component.\")}const defaultStore=Object.freeze({getState:notInAContext,replaceState:notInAContext,subscribeToTransactions:notInAContext,addTransactionMetadata:notInAContext,fireNodeSubscriptions:notInAContext});function startNextTreeIfNeeded(storeState){null===storeState.nextTree&&(storeState.nextTree={...storeState.currentTree,dirtyAtoms:new Set,transactionMetadata:{}})}const AppContext=react.createContext({current:defaultStore}),useStoreRef=()=>useContext(AppContext);function Batcher(props){const storeRef=useStoreRef(),[_,setState]=useState([]);return props.setNotifyBatcherOfChange(()=>setState({})),useEffect(()=>{Recoil_Queue.enqueueExecution(\"Batcher\",()=>{const storeState=storeRef.current.getState(),{nextTree:nextTree}=storeState;if(null===nextTree)return;nextTree.dirtyAtoms.size&&storeState.transactionSubscriptions.forEach(sub=>sub(storeRef.current)),storeState.queuedComponentCallbacks.forEach(cb=>cb(nextTree)),storeState.queuedComponentCallbacks.splice(0,storeState.queuedComponentCallbacks.length),storeState.currentTree=nextTree,storeState.nextTree=null})}),null}let nextID=0;var Recoil_RecoilRoot_react={useStoreRef:useStoreRef,RecoilRoot:function({initializeState_DEPRECATED:initializeState_DEPRECATED,initializeState:initializeState,children:children}){let storeState;const notifyBatcherOfChange=useRef(null),store={getState:()=>storeState.current,replaceState:replacer=>{const storeState=storeRef.current.getState();startNextTreeIfNeeded(storeState);const nextTree=Recoil_nullthrows(storeState.nextTree),replaced=replacer(nextTree);replaced!==nextTree&&(storeState.nextTree=replaced,Recoil_nullthrows(notifyBatcherOfChange.current)())},subscribeToTransactions:callback=>{const id=nextID++;return storeRef.current.getState().transactionSubscriptions.set(id,callback),{release:()=>{storeRef.current.getState().transactionSubscriptions.delete(id)}}},addTransactionMetadata:metadata=>{startNextTreeIfNeeded(storeRef.current.getState());for(const k of Object.keys(metadata))Recoil_nullthrows(storeRef.current.getState().nextTree).transactionMetadata[k]=metadata[k]},fireNodeSubscriptions:function(updatedNodes,when){fireNodeSubscriptions$1(storeRef.current,updatedNodes,when)}},storeRef=useRef(store);return storeState=useRef(null!=initializeState_DEPRECATED?function(store,initializeState){const initial=makeEmptyStoreState$1();return initializeState({set:(atom,value)=>{initial.currentTree=setNodeValue$2(store,initial.currentTree,atom.key,value)[0]},setUnvalidatedAtomValues:atomValues=>{atomValues.forEach((v,k)=>{initial.currentTree=setUnvalidatedAtomValue$2(initial.currentTree,k,v)})}}),initial}(store,initializeState_DEPRECATED):null!=initializeState?function(initializeState){const snapshot=freshSnapshot$1().map(initializeState);return makeStoreState$2(snapshot.getStore_INTERNAL().getState().currentTree)}(initializeState):makeEmptyStoreState$1()),react.createElement(AppContext.Provider,{value:storeRef},react.createElement(Batcher,{setNotifyBatcherOfChange:function(x){notifyBatcherOfChange.current=x}}),children)}};var Recoil_differenceSets=function(set,...setsWithValuesToRemove){const ret=new Set;FIRST:for(const value of set){for(const otherSet of setsWithValuesToRemove)if(otherSet.has(value))continue FIRST;ret.add(value)}return ret};var Recoil_filterMap=function(map,callback){const result=new Map;for(const[key,value]of map)callback(value,key)&&result.set(key,value);return result};var Recoil_intersectSets=function(first,...rest){const ret=new Set;FIRST:for(const value of first){for(const otherSet of rest)if(!otherSet.has(value))continue FIRST;ret.add(value)}return ret};var Recoil_invariant=function(condition,message){if(!condition)throw new Error(message)};var Recoil_mergeMaps=function(...maps){const result=new Map;for(let i=0;i<maps.length;i++){const iterator=maps[i].keys();let nextKey;for(;!(nextKey=iterator.next()).done;)result.set(nextKey.value,maps[i].get(nextKey.value))}return result};const{useCallback:useCallback,useEffect:useEffect$1,useMemo:useMemo,useRef:useRef$1,useState:useState$1}=react,{peekNodeLoadable:peekNodeLoadable$2,setNodeValue:setNodeValue$3}=Recoil_FunctionalCore,{DEFAULT_VALUE:DEFAULT_VALUE$2,getNode:getNode$2,nodes:nodes$1}=Recoil_Node,{useStoreRef:useStoreRef$1}=Recoil_RecoilRoot_react,{AbstractRecoilValue:AbstractRecoilValue$2,getRecoilValueAsLoadable:getRecoilValueAsLoadable$2,setRecoilValue:setRecoilValue$2,setUnvalidatedRecoilValue:setUnvalidatedRecoilValue$1,subscribeToRecoilValue:subscribeToRecoilValue$1,valueFromValueOrUpdater:valueFromValueOrUpdater$2}=Recoil_RecoilValueInterface,{Snapshot:Snapshot$1,cloneSnapshot:cloneSnapshot$1}=require$$6,{setByAddingToSet:setByAddingToSet$2}=Recoil_CopyOnWrite;function useInterface(){const storeRef=useStoreRef$1(),[_,forceUpdate]=useState$1([]),recoilValuesUsed=useRef$1(new Set);recoilValuesUsed.current=new Set;const previousSubscriptions=useRef$1(new Set),subscriptions=useRef$1(new Map),unsubscribeFrom=useCallback(key=>{const sub=subscriptions.current.get(key);sub&&(sub.release(storeRef.current),subscriptions.current.delete(key))},[storeRef,subscriptions]);return useEffect$1(()=>{const store=storeRef.current;function updateState(_state,key){subscriptions.current.has(key)&&forceUpdate([])}Recoil_differenceSets(recoilValuesUsed.current,previousSubscriptions.current).forEach(key=>{if(subscriptions.current.has(key))return;const sub=subscribeToRecoilValue$1(store,new AbstractRecoilValue$2(key),state=>{Recoil_Tracing.trace(\"RecoilValue subscription fired\",key,()=>{updateState(0,key)})});subscriptions.current.set(key,sub),Recoil_Tracing.trace(\"initial update on subscribing\",key,()=>{updateState(store.getState(),key)})}),Recoil_differenceSets(previousSubscriptions.current,recoilValuesUsed.current).forEach(key=>{unsubscribeFrom(key)}),previousSubscriptions.current=recoilValuesUsed.current}),useEffect$1(()=>{const subs=subscriptions.current;return()=>subs.forEach((_,key)=>unsubscribeFrom(key))},[unsubscribeFrom]),useMemo(()=>{function useSetRecoilState(recoilState){return newValueOrUpdater=>{const newValue=valueFromValueOrUpdater$2(storeRef.current,recoilState,newValueOrUpdater);setRecoilValue$2(storeRef.current,recoilState,newValue)}}function useRecoilValueLoadable(recoilValue){return recoilValuesUsed.current.has(recoilValue.key)||(recoilValuesUsed.current=setByAddingToSet$2(recoilValuesUsed.current,recoilValue.key)),getRecoilValueAsLoadable$2(storeRef.current,recoilValue)}function useRecoilValue(recoilValue){return function(loadable,atom,storeRef){if(\"hasValue\"===loadable.state)return loadable.contents;if(\"loading\"===loadable.state){throw new Promise(resolve=>{storeRef.current.getState().suspendedComponentResolvers.add(resolve)})}throw\"hasError\"===loadable.state?loadable.contents:new Error(`Invalid value of loadable atom \"${atom.key}\"`)}(useRecoilValueLoadable(recoilValue),recoilValue,storeRef)}return{getRecoilValue:useRecoilValue,getRecoilValueLoadable:useRecoilValueLoadable,getRecoilState:function(recoilState){return[useRecoilValue(recoilState),useSetRecoilState(recoilState)]},getRecoilStateLoadable:function(recoilState){return[useRecoilValueLoadable(recoilState),useSetRecoilState(recoilState)]},getSetRecoilState:useSetRecoilState,getResetRecoilState:function(recoilState){return()=>setRecoilValue$2(storeRef.current,recoilState,DEFAULT_VALUE$2)}}},[recoilValuesUsed,storeRef])}function useTransactionSubscription(callback){const storeRef=useStoreRef$1();useEffect$1(()=>storeRef.current.subscribeToTransactions(callback).release,[callback,storeRef])}function useTreeStateClone_DEPRECATED(){const[_,setState]=useState$1(0);useTransactionSubscription(useCallback(()=>setState(x=>x+1),[]));const storeRef=useStoreRef$1();return{transactionMetadata:{...(state=storeRef.current.getState().currentTree).transactionMetadata},atomValues:new Map(state.atomValues),nonvalidatedAtoms:new Map(state.nonvalidatedAtoms),dirtyAtoms:new Set(state.dirtyAtoms),nodeDeps:new Map(state.nodeDeps),nodeToNodeSubscriptions:Recoil_mapMap(state.nodeToNodeSubscriptions,keys=>new Set(keys)),nodeToComponentSubscriptions:Recoil_mapMap(state.nodeToComponentSubscriptions,subsByAtom=>new Map(subsByAtom))};var state}function externallyVisibleAtomValuesInState(state){const atomValues=state.atomValues,persistedAtomContentsValues=Recoil_mapMap(Recoil_filterMap(atomValues,(v,k)=>{var _node$options;const persistence=null===(_node$options=getNode$2(k).options)||void 0===_node$options?void 0:_node$options.persistence_UNSTABLE;return null!=persistence&&\"none\"!==persistence.type&&\"hasValue\"===v.state}),v=>v.contents);return Recoil_mergeMaps(state.nonvalidatedAtoms,persistedAtomContentsValues)}function useGotoRecoilSnapshot(){const storeRef=useStoreRef$1();return useCallback(snapshot=>{reactDom.unstable_batchedUpdates(()=>{storeRef.current.replaceState(prevState=>{const nextState=snapshot.getStore_INTERNAL().getState().currentTree,updatedKeys=new Set;for(const keys of[prevState.atomValues.keys(),nextState.atomValues.keys()])for(const key of keys){var _prevState$atomValues,_nextState$atomValues;(null===(_prevState$atomValues=prevState.atomValues.get(key))||void 0===_prevState$atomValues?void 0:_prevState$atomValues.contents)!==(null===(_nextState$atomValues=nextState.atomValues.get(key))||void 0===_nextState$atomValues?void 0:_nextState$atomValues.contents)&&updatedKeys.add(key)}return storeRef.current.fireNodeSubscriptions(updatedKeys,\"enqueue\"),{...nextState,nodeToComponentSubscriptions:prevState.nodeToComponentSubscriptions}})})},[storeRef])}class Sentinel{}const SENTINEL=new Sentinel;var Recoil_Hooks={useRecoilCallback:function(fn,deps){const storeRef=useStoreRef$1(),gotoSnapshot=useGotoRecoilSnapshot();return useCallback((...args)=>{const snapshot=cloneSnapshot$1(storeRef.current.getState().currentTree);function set(recoilState,newValueOrUpdater){const newValue=valueFromValueOrUpdater$2(storeRef.current,recoilState,newValueOrUpdater);setRecoilValue$2(storeRef.current,recoilState,newValue)}function reset(recoilState){setRecoilValue$2(storeRef.current,recoilState,DEFAULT_VALUE$2)}let ret=SENTINEL;return reactDom.unstable_batchedUpdates(()=>{ret=fn({set:set,reset:reset,snapshot:snapshot,gotoSnapshot:gotoSnapshot})(...args)}),ret instanceof Sentinel&&Recoil_invariant(!1),ret},null!=deps?[...deps,storeRef]:void 0)},useRecoilValue:function(recoilValue){return useInterface().getRecoilValue(recoilValue)},useRecoilValueLoadable:function(recoilValue){return useInterface().getRecoilValueLoadable(recoilValue)},useRecoilState:function(recoilState){const recoilInterface=useInterface(),[value]=recoilInterface.getRecoilState(recoilState);return[value,useCallback(recoilInterface.getSetRecoilState(recoilState),[recoilState])]},useRecoilStateLoadable:function(recoilState){const recoilInterface=useInterface(),[value]=recoilInterface.getRecoilStateLoadable(recoilState);return[value,useCallback(recoilInterface.getSetRecoilState(recoilState),[recoilState])]},useSetRecoilState:function(recoilState){return useCallback(useInterface().getSetRecoilState(recoilState),[recoilState])},useResetRecoilState:function(recoilState){return useCallback(useInterface().getResetRecoilState(recoilState),[recoilState])},useRecoilInterface:useInterface,useSnapshotWithStateChange_DEPRECATED:function(transaction){const storeRef=useStoreRef$1();let snapshot=useTreeStateClone_DEPRECATED();transaction(({key:key},updater)=>{[snapshot]=setNodeValue$3(storeRef.current,snapshot,key,peekNodeLoadable$2(storeRef.current,snapshot,key).map(updater))});const atomValues=Recoil_mapMap(snapshot.atomValues,v=>v.contents),updatedAtoms=Recoil_intersectSets(snapshot.dirtyAtoms,new Set(atomValues.keys()));return{atomValues:atomValues,updatedAtoms:updatedAtoms}},useTransactionSubscription_DEPRECATED:useTransactionSubscription,useTransactionObservation_DEPRECATED:function(callback){useTransactionSubscription(useCallback(store=>{const previousState=store.getState().currentTree;let nextState=store.getState().nextTree;nextState||(nextState=store.getState().currentTree);const atomValues=externallyVisibleAtomValuesInState(nextState),previousAtomValues=externallyVisibleAtomValuesInState(previousState),atomInfo=Recoil_mapMap(nodes$1,node=>{var _node$options$persist,_node$options2,_node$options2$persis,_node$options$persist2,_node$options3,_node$options3$persis;return{persistence_UNSTABLE:{type:null!==(_node$options$persist=null===(_node$options2=node.options)||void 0===_node$options2||null===(_node$options2$persis=_node$options2.persistence_UNSTABLE)||void 0===_node$options2$persis?void 0:_node$options2$persis.type)&&void 0!==_node$options$persist?_node$options$persist:\"none\",backButton:null!==(_node$options$persist2=null===(_node$options3=node.options)||void 0===_node$options3||null===(_node$options3$persis=_node$options3.persistence_UNSTABLE)||void 0===_node$options3$persis?void 0:_node$options3$persis.backButton)&&void 0!==_node$options$persist2&&_node$options$persist2}}}),modifiedAtoms=new Set(nextState.dirtyAtoms);callback({atomValues:atomValues,previousAtomValues:previousAtomValues,atomInfo:atomInfo,modifiedAtoms:modifiedAtoms,transactionMetadata:{...nextState.transactionMetadata}})},[callback]))},useRecoilTransactionObserver:function(callback){useTransactionSubscription(useCallback(store=>{const previousState=store.getState().currentTree;let nextState=store.getState().nextTree;nextState||(nextState=previousState),callback({snapshot:cloneSnapshot$1(nextState),previousSnapshot:cloneSnapshot$1(previousState)})},[callback]))},useRecoilSnapshot:function(){const store=useStoreRef$1(),[snapshot,setSnapshot]=useState$1(()=>cloneSnapshot$1(store.current.getState().currentTree));return useTransactionSubscription(useCallback(store=>{var _store$getState$nextT;return setSnapshot(cloneSnapshot$1(null!==(_store$getState$nextT=store.getState().nextTree)&&void 0!==_store$getState$nextT?_store$getState$nextT:store.getState().currentTree))},[])),snapshot},useGoToSnapshot_DEPRECATED:function(){const storeRef=useStoreRef$1();return snapshot=>{reactDom.unstable_batchedUpdates(()=>{snapshot.updatedAtoms.forEach(key=>{setRecoilValue$2(storeRef.current,new AbstractRecoilValue$2(key),snapshot.atomValues.get(key))})})}},useGotoRecoilSnapshot:useGotoRecoilSnapshot,useSetUnvalidatedAtomValues:function(){const storeRef=useStoreRef$1();return(values,transactionMetadata={})=>{reactDom.unstable_batchedUpdates(()=>{storeRef.current.addTransactionMetadata(transactionMetadata),values.forEach((value,key)=>setUnvalidatedRecoilValue$1(storeRef.current,new AbstractRecoilValue$2(key),value))})}}};var Recoil_isPromise=function(p){return!!p&&\"function\"==typeof p.then};const loadableAccessors={getValue(){if(\"hasValue\"!==this.state)throw this.contents;return this.contents},toPromise(){return\"hasValue\"===this.state?Promise.resolve(this.contents):\"hasError\"===this.state?Promise.reject(this.contents):this.contents},valueMaybe(){return\"hasValue\"===this.state?this.contents:void 0},valueOrThrow(){if(\"hasValue\"!==this.state)throw new Error(`Loadable expected value, but in \"${this.state}\" state`);return this.contents},errorMaybe(){return\"hasError\"===this.state?this.contents:void 0},errorOrThrow(){if(\"hasError\"!==this.state)throw new Error(`Loadable expected error, but in \"${this.state}\" state`);return this.contents},promiseMaybe(){return\"loading\"===this.state?this.contents:void 0},promiseOrThrow(){if(\"loading\"!==this.state)throw new Error(`Loadable expected promise, but in \"${this.state}\" state`);return this.contents},map(map){if(\"hasError\"===this.state)return this;if(\"hasValue\"===this.state)try{const next=map(this.contents);return Recoil_isPromise(next)?loadableWithPromise(next):loadableWithValue(next)}catch(e){return Recoil_isPromise(e)?loadableWithPromise(e.next(()=>map(this.contents))):loadableWithError(e)}if(\"loading\"===this.state)return loadableWithPromise(this.contents.then(map).catch(e=>{if(Recoil_isPromise(e))return e.then(()=>map(this.contents));throw e}));throw new Error(\"Invalid Loadable state\")}};function loadableWithValue(value){return Object.freeze({state:\"hasValue\",contents:value,...loadableAccessors})}function loadableWithError(error){return Object.freeze({state:\"hasError\",contents:error,...loadableAccessors})}function loadableWithPromise(promise){return Object.freeze({state:\"loading\",contents:promise,...loadableAccessors})}var Recoil_Loadable={loadableWithValue:loadableWithValue,loadableWithError:loadableWithError,loadableWithPromise:loadableWithPromise,loadableLoading:function(){return loadableWithPromise(new Promise(()=>{}))},loadableAll:function(inputs){return inputs.every(i=>\"hasValue\"===i.state)?loadableWithValue(inputs.map(i=>i.contents)):inputs.some(i=>\"hasError\"===i.state)?loadableWithError(Recoil_nullthrows(inputs.find(i=>\"hasError\"===i.state),\"Invalid loadable passed to loadableAll\").contents):loadableWithPromise(Promise.all(inputs.map(i=>i.contents)))}};var Recoil_isNode=function(object){var _ownerDocument,_doc$defaultView;if(\"undefined\"==typeof window)return!1;const defaultView=null!==(_doc$defaultView=(null!=object?null!==(_ownerDocument=object.ownerDocument)&&void 0!==_ownerDocument?_ownerDocument:object:document).defaultView)&&void 0!==_doc$defaultView?_doc$defaultView:window;return!(null==object||!(\"function\"==typeof defaultView.Node?object instanceof defaultView.Node:\"object\"==typeof object&&\"number\"==typeof object.nodeType&&\"string\"==typeof object.nodeName))};var Recoil_deepFreezeValue=function deepFreezeValue(value){if(\"object\"==typeof value&&!function(value){if(null===value||\"object\"!=typeof value)return!0;switch(typeof value.$$typeof){case\"symbol\":case\"number\":return!0}return null!=value[\"@@__IMMUTABLE_ITERABLE__@@\"]||null!=value[\"@@__IMMUTABLE_KEYED__@@\"]||null!=value[\"@@__IMMUTABLE_INDEXED__@@\"]||null!=value[\"@@__IMMUTABLE_ORDERED__@@\"]||null!=value[\"@@__IMMUTABLE_RECORD__@@\"]||(!!Recoil_isNode(value)||!!Recoil_isPromise(value))}(value)){Object.freeze(value);for(const key in value)if(Object.prototype.hasOwnProperty.call(value,key)){const prop=value[key];\"object\"!=typeof prop||null==prop||Object.isFrozen(prop)||deepFreezeValue(prop)}Object.seal(value)}};const LEAF=Symbol(\"ArrayKeyedMap\"),emptyMap$1=new Map;class ArrayKeyedMap{constructor(existing){if(this._base=new Map,existing instanceof ArrayKeyedMap)for(const[k,v]of existing.entries())this.set(k,v);else if(existing)for(const[k,v]of existing)this.set(k,v);return this}get(key){const ks=Array.isArray(key)?key:[key];let map=this._base;return ks.forEach(k=>{var _map$get;map=null!==(_map$get=map.get(k))&&void 0!==_map$get?_map$get:emptyMap$1}),void 0===map?void 0:map.get(LEAF)}set(key,value){const ks=Array.isArray(key)?key:[key];let map=this._base,next=map;return ks.forEach(k=>{next=map.get(k),next||(next=new Map,map.set(k,next)),map=next}),next.set(LEAF,value),this}delete(key){const ks=Array.isArray(key)?key:[key];let map=this._base,next=map;return ks.forEach(k=>{next=map.get(k),next||(next=new Map,map.set(k,next)),map=next}),next.delete(LEAF),this}entries(){const answer=[];return function recurse(level,prefix){level.forEach((v,k)=>{k===LEAF?answer.push([prefix,v]):recurse(v,prefix.concat(k))})}(this._base,[]),answer.values()}toBuiltInMap(){return new Map(this.entries())}}var Recoil_ArrayKeyedMap=ArrayKeyedMap;var Recoil_cacheWithReferenceEquality=function(){return new Recoil_ArrayKeyedMap};var Recoil_everySet=function(set,callback,context){const iterator=set.entries();let current=iterator.next();for(;!current.done;){const entry=current.value;if(!callback.call(context,entry[1],entry[0],set))return!1;current=iterator.next()}return!0};var Recoil_equalsSet=function(one,two){return one.size===two.size&&Recoil_everySet(one,value=>two.has(value))};var Recoil_PerformanceTimings={startPerfBlock:function(_id){return()=>null}};Object.freeze(new Set);const{mapBySettingInMap:mapBySettingInMap$2,mapByUpdatingInMap:mapByUpdatingInMap$2,setByAddingToSet:setByAddingToSet$3,setByDeletingFromSet:setByDeletingFromSet$1}=Recoil_CopyOnWrite,{detectCircularDependencies:detectCircularDependencies$1,getNodeLoadable:getNodeLoadable$2,setNodeValue:setNodeValue$4}=Recoil_FunctionalCore,{loadableWithError:loadableWithError$1,loadableWithPromise:loadableWithPromise$1,loadableWithValue:loadableWithValue$1}=Recoil_Loadable,{DEFAULT_VALUE:DEFAULT_VALUE$3,RecoilValueNotReady:RecoilValueNotReady$2,registerNode:registerNode$1}=Recoil_Node,{startPerfBlock:startPerfBlock$1}=Recoil_PerformanceTimings,{isRecoilValue:isRecoilValue$1}=require$$2,emptySet$2=Object.freeze(new Set);function cacheKeyFromDepValues(depValues){const answer=[];for(const key of Array.from(depValues.keys()).sort()){const loadable=Recoil_nullthrows(depValues.get(key));answer.push(key),answer.push(loadable.contents)}return answer}var Recoil_selector=function(options){const{key:key,get:get,cacheImplementation_UNSTABLE:cacheImplementation}=options,set=null!=options.set?options.set:void 0;let cache=null!=cacheImplementation?cacheImplementation:Recoil_cacheWithReferenceEquality();function getFromCache(store,state){var _state$nodeDeps$get;let newState=state;const currentDeps=null!==(_state$nodeDeps$get=state.nodeDeps.get(key))&&void 0!==_state$nodeDeps$get?_state$nodeDeps$get:emptySet$2,cacheKey=cacheKeyFromDepValues(new Map(Array.from(currentDeps).sort().map(depKey=>{const[nextState,loadable]=getNodeLoadable$2(store,newState,depKey);return newState=nextState,[depKey,loadable]}))),cached=cache.get(cacheKey);if(null!=cached)return[newState,cached];const[nextState,loadable,newDepValues]=function(store,state){var _state$nodeDeps$get2;const[newStateFromEvaluate,loadable,newDepValues]=function(store,state){const endPerfBlock=startPerfBlock$1(key);let newState=state;const depValues=new Map;function getRecoilValue({key:key}){let loadable;if([newState,loadable]=getNodeLoadable$2(store,newState,key),depValues.set(key,loadable),\"hasValue\"===loadable.state)return loadable.contents;throw loadable.contents}try{const output=get({get:getRecoilValue}),result=isRecoilValue$1(output)?getRecoilValue(output):output,loadable=Recoil_isPromise(result)?loadableWithPromise$1(result.finally(endPerfBlock)):(endPerfBlock(),loadableWithValue$1(result));return[newState,loadable,depValues]}catch(errorOrDepPromise){const loadable=Recoil_isPromise(errorOrDepPromise)?loadableWithPromise$1(errorOrDepPromise.then(()=>{let loadable=loadableWithError$1(new Error(\"Internal Recoil Selector Error\"));if(store.replaceState(asyncState=>{let newAsyncState;return[newAsyncState,loadable]=getFromCache(store,asyncState),newAsyncState}),\"hasError\"===loadable.state)throw loadable.contents;return loadable.contents}).finally(endPerfBlock)):(endPerfBlock(),loadableWithError$1(errorOrDepPromise));return[newState,loadable,depValues]}}(store,state);let newState=newStateFromEvaluate;const oldDeps=null!==(_state$nodeDeps$get2=state.nodeDeps.get(key))&&void 0!==_state$nodeDeps$get2?_state$nodeDeps$get2:emptySet$2,newDeps=new Set(newDepValues.keys());newState=Recoil_equalsSet(oldDeps,newDeps)?newState:{...newState,nodeDeps:mapBySettingInMap$2(newState.nodeDeps,key,newDeps)};const addedDeps=Recoil_differenceSets(newDeps,oldDeps),removedDeps=Recoil_differenceSets(oldDeps,newDeps);for(const upstreamNode of addedDeps)newState={...newState,nodeToNodeSubscriptions:mapByUpdatingInMap$2(newState.nodeToNodeSubscriptions,upstreamNode,subs=>setByAddingToSet$3(null!=subs?subs:emptySet$2,key))};for(const upstreamNode of removedDeps)newState={...newState,nodeToNodeSubscriptions:mapByUpdatingInMap$2(newState.nodeToNodeSubscriptions,upstreamNode,subs=>setByDeletingFromSet$1(null!=subs?subs:emptySet$2,key))};return[newState,loadable,newDepValues]}(store,newState);newState=nextState;const newCacheKey=cacheKeyFromDepValues(newDepValues);return function(store,cacheKey,loadable){\"loading\"!==loadable.state?!0==!options.dangerouslyAllowMutability&&Recoil_deepFreezeValue(loadable.contents):loadable.contents.then(result=>(!0==!options.dangerouslyAllowMutability&&Recoil_deepFreezeValue(result),cache=cache.set(cacheKey,loadableWithValue$1(result)),store.fireNodeSubscriptions(new Set([key]),\"now\"),result)).catch(error=>(Recoil_isPromise(error)||(!0==!options.dangerouslyAllowMutability&&Recoil_deepFreezeValue(error),cache=cache.set(cacheKey,loadableWithError$1(error)),store.fireNodeSubscriptions(new Set([key]),\"now\")),error)),cache=cache.set(cacheKey,loadable)}(store,newCacheKey,loadable),[newState,loadable]}function myGet(store,state){return getFromCache(store,state)}if(null!=set){return registerNode$1({key:key,options:options,get:myGet,set:function(store,state,newValue){let newState=state;const writtenNodes=new Set;function getRecoilValue({key:key}){const[nextState,loadable]=getNodeLoadable$2(store,newState,key);if(newState=nextState,\"hasValue\"===loadable.state)return loadable.contents;throw\"loading\"===loadable.state?new RecoilValueNotReady$2(key):loadable.contents}function setRecoilState(recoilState,valueOrUpdater){const newValue=\"function\"==typeof valueOrUpdater?valueOrUpdater(getRecoilValue(recoilState)):valueOrUpdater;let written;[newState,written]=setNodeValue$4(store,newState,recoilState.key,newValue),written.forEach(atom=>writtenNodes.add(atom))}return set({set:setRecoilState,get:getRecoilValue,reset:function(recoilState){setRecoilState(recoilState,DEFAULT_VALUE$3)}},newValue),[newState,writtenNodes]}})}return registerNode$1({key:key,options:options,get:myGet})};const{loadableWithValue:loadableWithValue$2}=Recoil_Loadable,{DEFAULT_VALUE:DEFAULT_VALUE$4,DefaultValue:DefaultValue$1,registerNode:registerNode$2}=Recoil_Node,{isRecoilValue:isRecoilValue$2}=require$$2,{mapByDeletingFromMap:mapByDeletingFromMap$2,mapBySettingInMap:mapBySettingInMap$3,setByAddingToSet:setByAddingToSet$4}=Recoil_CopyOnWrite;function atom(options){const{default:optionsDefault,...restOptions}=options;return isRecoilValue$2(optionsDefault)||Recoil_isPromise(optionsDefault)?function(options){const base=atom({...options,default:DEFAULT_VALUE$4,persistence_UNSTABLE:void 0===options.persistence_UNSTABLE?void 0:{...options.persistence_UNSTABLE,validator:storedValue=>storedValue instanceof DefaultValue$1?storedValue:Recoil_nullthrows(options.persistence_UNSTABLE).validator(storedValue,DEFAULT_VALUE$4)}});return Recoil_selector({key:options.key+\"__withFallback\",get:({get:get})=>{const baseValue=get(base);return baseValue instanceof DefaultValue$1?options.default:baseValue},set:({set:set},newValue)=>set(base,newValue),dangerouslyAllowMutability:options.dangerouslyAllowMutability})}({...restOptions,default:optionsDefault}):function(options){const{key:key,persistence_UNSTABLE:persistence}=options;return registerNode$2({key:key,options:options,get:(_store,state)=>{if(state.atomValues.has(key))return[state,Recoil_nullthrows(state.atomValues.get(key))];if(state.nonvalidatedAtoms.has(key)){if(null==persistence)return[state,loadableWithValue$2(options.default)];const nonvalidatedValue=state.nonvalidatedAtoms.get(key),validatedValue=persistence.validator(nonvalidatedValue,DEFAULT_VALUE$4);return validatedValue instanceof DefaultValue$1?[{...state,nonvalidatedAtoms:mapByDeletingFromMap$2(state.nonvalidatedAtoms,key)},loadableWithValue$2(options.default)]:[{...state,atomValues:mapBySettingInMap$3(state.atomValues,key,loadableWithValue$2(validatedValue)),nonvalidatedAtoms:mapByDeletingFromMap$2(state.nonvalidatedAtoms,key)},loadableWithValue$2(validatedValue)]}return[state,loadableWithValue$2(options.default)]},set:(_store,state,newValue)=>(!0!==options.dangerouslyAllowMutability&&Recoil_deepFreezeValue(newValue),[{...state,dirtyAtoms:setByAddingToSet$4(state.dirtyAtoms,key),atomValues:newValue instanceof DefaultValue$1?mapByDeletingFromMap$2(state.atomValues,key):mapBySettingInMap$3(state.atomValues,key,loadableWithValue$2(newValue)),nonvalidatedAtoms:mapByDeletingFromMap$2(state.nonvalidatedAtoms,key)},new Set([key])])})}({...restOptions,default:optionsDefault})}var Recoil_atom=atom;var Recoil_stableStringify=function(x,opt={allowFunctions:!1}){return function stringify(x,opt,key){if(\"string\"==typeof x&&!x.includes('\"')&&!x.includes(\"\\\\\"))return`\"${x}\"`;switch(typeof x){case\"undefined\":return\"\";case\"boolean\":return x?\"true\":\"false\";case\"number\":case\"symbol\":return String(x);case\"string\":return JSON.stringify(x);case\"function\":if(!0!==(null==opt?void 0:opt.allowFunctions))throw new Error(\"Attempt to serialize function in a Recoil cache key\");return`__FUNCTION(${x.name})__`}return null===x?\"null\":\"object\"!=typeof x?null!==(_JSON$stringify=JSON.stringify(x))&&void 0!==_JSON$stringify?_JSON$stringify:\"\":Recoil_isPromise(x)?\"__PROMISE__\":Array.isArray(x)?`[${x.map((v,i)=>stringify(v,opt,i.toString()))}]`:\"function\"==typeof x.toJSON?stringify(x.toJSON(key),opt,key):x instanceof Map?stringify(Array.from(x).reduce((obj,[k,v])=>({...obj,[\"string\"==typeof k?k:stringify(k,opt)]:v}),{}),opt,key):x instanceof Set?stringify(Array.from(x).sort((a,b)=>stringify(a,opt).localeCompare(stringify(b,opt))),opt,key):null!=x[Symbol.iterator]&&\"function\"==typeof x[Symbol.iterator]?stringify(Array.from(x),opt,key):`{${Object.keys(x).filter(key=>void 0!==x[key]).sort().map(key=>`${stringify(key,opt)}:${stringify(x[key],opt,key)}`).join(\",\")}}`;var _JSON$stringify}(x,opt)};var Recoil_cacheWithValueEquality=function(){const map=new Map,cache={get:key=>map.get(Recoil_stableStringify(key)),set:(key,value)=>(map.set(Recoil_stableStringify(key),value),cache),map:map};return cache};let nextIndex=0;var Recoil_selectorFamily=function(options){var _options$cacheImpleme,_options$cacheImpleme2;let selectorCache=null!==(_options$cacheImpleme=null===(_options$cacheImpleme2=options.cacheImplementationForParams_UNSTABLE)||void 0===_options$cacheImpleme2?void 0:_options$cacheImpleme2.call(options))&&void 0!==_options$cacheImpleme?_options$cacheImpleme:Recoil_cacheWithValueEquality();return params=>{var _stableStringify,_options$cacheImpleme3;const cachedSelector=selectorCache.get(params);if(null!=cachedSelector)return cachedSelector;const myKey=`${options.key}__selectorFamily/${null!==(_stableStringify=Recoil_stableStringify(params,{allowFunctions:!0}))&&void 0!==_stableStringify?_stableStringify:\"void\"}/${nextIndex++}`,myGet=callbacks=>options.get(params)(callbacks),myCacheImplementation=null===(_options$cacheImpleme3=options.cacheImplementation_UNSTABLE)||void 0===_options$cacheImpleme3?void 0:_options$cacheImpleme3.call(options);let newSelector;if(null!=options.set){const set=options.set;newSelector=Recoil_selector({key:myKey,get:myGet,set:(callbacks,newValue)=>set(params)(callbacks,newValue),cacheImplementation_UNSTABLE:myCacheImplementation,dangerouslyAllowMutability:options.dangerouslyAllowMutability})}else newSelector=Recoil_selector({key:myKey,get:myGet,cacheImplementation_UNSTABLE:myCacheImplementation,dangerouslyAllowMutability:options.dangerouslyAllowMutability});return selectorCache=selectorCache.set(params,newSelector),newSelector}},ParameterizedAtomTaggedValue_DEPRECATED=getCjsExportFromNamespace(Object.freeze({__proto__:null}));const{DEFAULT_VALUE:DEFAULT_VALUE$5,DefaultValue:DefaultValue$2}=Recoil_Node;function isSuperset(setA,setB){return Recoil_everySet(setB,b=>setA.has(b))}const pick=(object,chosenKeys)=>Array.from(chosenKeys).reduce((obj,key)=>({...obj,[key]:object[key]}),{});function mapPersistenceSettings_DEPRECATED(settings){if(null==settings)return;const{...passthrough}=settings;return{...passthrough,validator:storedValue=>storedValue instanceof ParameterizedAtomTaggedValue_DEPRECATED?new ParameterizedAtomTaggedValue_DEPRECATED(storedValue.value.filter(([keys,map])=>keys instanceof Set&&map instanceof Map).map(([keys,map])=>[keys,Array.from(map.entries()).reduce((acc,[k,v])=>{const validatedValue=passthrough.validator(v,DEFAULT_VALUE$5);return validatedValue instanceof DefaultValue$2||acc.set(k,validatedValue),acc},new Map)])):passthrough.validator(storedValue,DEFAULT_VALUE$5)}}var Recoil_atomFamily=function(options){let atomCache=Recoil_cacheWithValueEquality();const legacyAtomOptions={key:options.key,default:DEFAULT_VALUE$5,persistence_UNSTABLE:mapPersistenceSettings_DEPRECATED(options.persistence_UNSTABLE)};let legacyAtom;legacyAtom=Recoil_atom(legacyAtomOptions);const atomFamilyDefault=Recoil_selectorFamily({key:options.key+\"__atomFamily/Default\",get:param=>({get:get})=>{const legacyValue=get(\"function\"==typeof legacyAtom?legacyAtom(param):legacyAtom);if(!(legacyValue instanceof DefaultValue$2)){const upgradedValue=function(baseValue,parameter){if(!(baseValue instanceof ParameterizedAtomTaggedValue_DEPRECATED))return baseValue;if(\"object\"!=typeof parameter||null==parameter||Array.isArray(parameter))return DEFAULT_VALUE$5;const entries=baseValue.value,parameterKeys=new Set(Object.keys(parameter));for(const[entryParameterKeys,entryMap]of entries)if(isSuperset(parameterKeys,entryParameterKeys)){const contextOrSubcontext=parameterKeys.size===entryParameterKeys.size?parameter:pick(parameter,entryParameterKeys),value=entryMap.get(Recoil_stableStringify(contextOrSubcontext));if(void 0!==value)return value}return DEFAULT_VALUE$5}(legacyValue,param);if(!(upgradedValue instanceof DefaultValue$2))return upgradedValue}return\"function\"==typeof options.default?options.default(param):options.default},dangerouslyAllowMutability:options.dangerouslyAllowMutability});return params=>{var _stableStringify;const cachedAtom=atomCache.get(params);if(null!=cachedAtom)return cachedAtom;const newAtom=Recoil_atom({key:`${options.key}__${null!==(_stableStringify=Recoil_stableStringify(params))&&void 0!==_stableStringify?_stableStringify:\"void\"}`,default:atomFamilyDefault(params),persistence_UNSTABLE:options.persistence_UNSTABLE,dangerouslyAllowMutability:options.dangerouslyAllowMutability});return atomCache=atomCache.set(params,newAtom),newAtom}};const constantSelector=Recoil_selectorFamily({key:\"__constant\",get:constant=>()=>constant,cacheImplementationForParams_UNSTABLE:Recoil_cacheWithReferenceEquality});var Recoil_constSelector=function(constant){return constantSelector(constant)};const throwingSelector=Recoil_selectorFamily({key:\"__error\",get:message=>()=>{throw new Error(message)},cacheImplementationForParams_UNSTABLE:Recoil_cacheWithReferenceEquality});var Recoil_errorSelector=function(message){return throwingSelector(message)};var Recoil_readOnlySelector=function(atom){return atom};const{loadableWithError:loadableWithError$2,loadableWithPromise:loadableWithPromise$2,loadableWithValue:loadableWithValue$3}=Recoil_Loadable;function concurrentRequests(getRecoilValue,deps){const results=Array(deps.length).fill(void 0),exceptions=Array(deps.length).fill(void 0);for(const[i,dep]of deps.entries())try{results[i]=getRecoilValue(dep)}catch(e){exceptions[i]=e}return[results,exceptions]}function isError(exp){return null!=exp&&!Recoil_isPromise(exp)}function unwrapDependencies(dependencies){return Array.isArray(dependencies)?dependencies:Object.getOwnPropertyNames(dependencies).map(key=>dependencies[key])}function wrapResults(dependencies,results){return Array.isArray(dependencies)?results:Object.getOwnPropertyNames(dependencies).reduce((out,key,idx)=>({...out,[key]:results[idx]}),{})}function wrapLoadables(dependencies,results,exceptions){return wrapResults(dependencies,exceptions.map((exception,idx)=>null==exception?loadableWithValue$3(results[idx]):Recoil_isPromise(exception)?loadableWithPromise$2(exception):loadableWithError$2(exception)))}var Recoil_WaitFor={waitForNone:Recoil_selectorFamily({key:\"__waitForNone\",get:dependencies=>({get:get})=>{const deps=unwrapDependencies(dependencies),[results,exceptions]=concurrentRequests(get,deps);return wrapLoadables(dependencies,results,exceptions)}}),waitForAny:Recoil_selectorFamily({key:\"__waitForAny\",get:dependencies=>({get:get})=>{const deps=unwrapDependencies(dependencies),[results,exceptions]=concurrentRequests(get,deps);if(exceptions.some(exp=>null==exp))return wrapLoadables(dependencies,results,exceptions);if(exceptions.every(isError))throw exceptions.find(isError);throw new Promise((resolve,reject)=>{for(const[i,exp]of exceptions.entries())Recoil_isPromise(exp)&&exp.then(result=>{results[i]=result,exceptions[i]=null,resolve(wrapLoadables(dependencies,results,exceptions))}).catch(error=>{exceptions[i]=error,exceptions.every(isError)&&reject(exceptions[0])})})}}),waitForAll:Recoil_selectorFamily({key:\"__waitForAll\",get:dependencies=>({get:get})=>{const deps=unwrapDependencies(dependencies),[results,exceptions]=concurrentRequests(get,deps);if(exceptions.every(exp=>null==exp))return wrapResults(dependencies,results);const error=exceptions.find(isError);if(null!=error)throw error;throw Promise.all(exceptions).then(results=>wrapResults(dependencies,results))}}),noWait:Recoil_selectorFamily({key:\"__noWait\",get:dependency=>({get:get})=>{try{return loadableWithValue$3(get(dependency))}catch(exception){return Recoil_isPromise(exception)?loadableWithPromise$2(exception):loadableWithError$2(exception)}}})};const{DefaultValue:DefaultValue$3}=Recoil_Node,{RecoilRoot:RecoilRoot$1}=Recoil_RecoilRoot_react,{isRecoilValue:isRecoilValue$3}=require$$2,{useGotoRecoilSnapshot:useGotoRecoilSnapshot$1,useRecoilCallback:useRecoilCallback$1,useRecoilSnapshot:useRecoilSnapshot$1,useRecoilState:useRecoilState$1,useRecoilStateLoadable:useRecoilStateLoadable$1,useRecoilTransactionObserver:useRecoilTransactionObserver$1,useRecoilValue:useRecoilValue$1,useRecoilValueLoadable:useRecoilValueLoadable$1,useResetRecoilState:useResetRecoilState$1,useSetRecoilState:useSetRecoilState$1,useSetUnvalidatedAtomValues:useSetUnvalidatedAtomValues$1,useTransactionObservation_DEPRECATED:useTransactionObservation_DEPRECATED$1}=Recoil_Hooks,{noWait:noWait$1,waitForAll:waitForAll$1,waitForAny:waitForAny$1,waitForNone:waitForNone$1}=Recoil_WaitFor;var Recoil_index={DefaultValue:DefaultValue$3,RecoilRoot:RecoilRoot$1,atom:Recoil_atom,selector:Recoil_selector,atomFamily:Recoil_atomFamily,selectorFamily:Recoil_selectorFamily,constSelector:Recoil_constSelector,errorSelector:Recoil_errorSelector,readOnlySelector:Recoil_readOnlySelector,useRecoilValue:useRecoilValue$1,useRecoilValueLoadable:useRecoilValueLoadable$1,useRecoilState:useRecoilState$1,useRecoilStateLoadable:useRecoilStateLoadable$1,useSetRecoilState:useSetRecoilState$1,useResetRecoilState:useResetRecoilState$1,useRecoilCallback:useRecoilCallback$1,useGotoRecoilSnapshot:useGotoRecoilSnapshot$1,useRecoilSnapshot:useRecoilSnapshot$1,useRecoilTransactionObserver_UNSTABLE:useRecoilTransactionObserver$1,useTransactionObservation_UNSTABLE:useTransactionObservation_DEPRECATED$1,useSetUnvalidatedAtomValues_UNSTABLE:useSetUnvalidatedAtomValues$1,noWait:noWait$1,waitForNone:waitForNone$1,waitForAny:waitForAny$1,waitForAll:waitForAll$1,isRecoilValue:isRecoilValue$3},Recoil_index_1=Recoil_index.DefaultValue,Recoil_index_2=Recoil_index.RecoilRoot,Recoil_index_3=Recoil_index.atom,Recoil_index_4=Recoil_index.selector,Recoil_index_5=Recoil_index.atomFamily,Recoil_index_6=Recoil_index.selectorFamily,Recoil_index_7=Recoil_index.constSelector,Recoil_index_8=Recoil_index.errorSelector,Recoil_index_9=Recoil_index.readOnlySelector,Recoil_index_10=Recoil_index.useRecoilValue,Recoil_index_11=Recoil_index.useRecoilValueLoadable,Recoil_index_12=Recoil_index.useRecoilState,Recoil_index_13=Recoil_index.useRecoilStateLoadable,Recoil_index_14=Recoil_index.useSetRecoilState,Recoil_index_15=Recoil_index.useResetRecoilState,Recoil_index_16=Recoil_index.useRecoilCallback,Recoil_index_17=Recoil_index.useGotoRecoilSnapshot,Recoil_index_18=Recoil_index.useRecoilSnapshot,Recoil_index_19=Recoil_index.useRecoilTransactionObserver_UNSTABLE,Recoil_index_20=Recoil_index.useTransactionObservation_UNSTABLE,Recoil_index_21=Recoil_index.useSetUnvalidatedAtomValues_UNSTABLE,Recoil_index_22=Recoil_index.noWait,Recoil_index_23=Recoil_index.waitForNone,Recoil_index_24=Recoil_index.waitForAny,Recoil_index_25=Recoil_index.waitForAll,Recoil_index_26=Recoil_index.isRecoilValue;exports.DefaultValue=Recoil_index_1,exports.RecoilRoot=Recoil_index_2,exports.atom=Recoil_index_3,exports.atomFamily=Recoil_index_5,exports.constSelector=Recoil_index_7,exports.default=Recoil_index,exports.errorSelector=Recoil_index_8,exports.isRecoilValue=Recoil_index_26,exports.noWait=Recoil_index_22,exports.readOnlySelector=Recoil_index_9,exports.selector=Recoil_index_4,exports.selectorFamily=Recoil_index_6,exports.useGotoRecoilSnapshot=Recoil_index_17,exports.useRecoilCallback=Recoil_index_16,exports.useRecoilSnapshot=Recoil_index_18,exports.useRecoilState=Recoil_index_12,exports.useRecoilStateLoadable=Recoil_index_13,exports.useRecoilTransactionObserver_UNSTABLE=Recoil_index_19,exports.useRecoilValue=Recoil_index_10,exports.useRecoilValueLoadable=Recoil_index_11,exports.useResetRecoilState=Recoil_index_15,exports.useSetRecoilState=Recoil_index_14,exports.useSetUnvalidatedAtomValues_UNSTABLE=Recoil_index_21,exports.useTransactionObservation_UNSTABLE=Recoil_index_20,exports.waitForAll=Recoil_index_25,exports.waitForAny=Recoil_index_24,exports.waitForNone=Recoil_index_23;\n"]},"metadata":{},"sourceType":"script"}