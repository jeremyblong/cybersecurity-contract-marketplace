{"ast":null,"code":"'use strict';\n\nvar CancelablePromise = require('../../util/cancelablepromise');\n\nvar DefaultPeerConnectionManager = require('./peerconnectionmanager');\n\nvar DefaultRoomV2 = require('./room');\n\nvar DefaultTransport = require('./twilioconnectiontransport');\n\nvar _a = require('../../util/twilio-video-errors'),\n    SignalingConnectionDisconnectedError = _a.SignalingConnectionDisconnectedError,\n    SignalingIncomingMessageInvalidError = _a.SignalingIncomingMessageInvalidError;\n\nvar _b = require('../../util'),\n    flatMap = _b.flatMap,\n    createRoomConnectEventPayload = _b.createRoomConnectEventPayload;\n\nfunction createCancelableRoomSignalingPromise(token, wsServer, localParticipant, encodingParameters, preferredCodecs, options) {\n  options = Object.assign({\n    PeerConnectionManager: DefaultPeerConnectionManager,\n    RoomV2: DefaultRoomV2,\n    Transport: DefaultTransport\n  }, options);\n  var adaptiveSimulcast = preferredCodecs.video[0] && preferredCodecs.video[0].adaptiveSimulcast === true;\n  var PeerConnectionManager = options.PeerConnectionManager,\n      RoomV2 = options.RoomV2,\n      Transport = options.Transport,\n      iceServers = options.iceServers,\n      log = options.log;\n  var peerConnectionManager = new PeerConnectionManager(encodingParameters, preferredCodecs, options);\n  var trackSenders = flatMap(localParticipant.tracks, function (trackV2) {\n    return [trackV2.trackTransceiver];\n  });\n  peerConnectionManager.setTrackSenders(trackSenders);\n  var cancellationError = new Error('Canceled');\n  var transport;\n  var cancelablePromise = new CancelablePromise(function (resolve, reject, isCanceled) {\n    var onIced = function onIced(iceServers) {\n      if (isCanceled()) {\n        reject(cancellationError);\n        return Promise.reject(cancellationError);\n      }\n\n      log.debug('Got ICE servers:', iceServers);\n      options.iceServers = iceServers;\n      peerConnectionManager.setConfiguration(options);\n      return peerConnectionManager.createAndOffer().then(function () {\n        if (isCanceled()) {\n          reject(cancellationError);\n          throw cancellationError;\n        }\n\n        log.debug('createAndOffer() succeeded.'); // NOTE(mmalavalli): PeerConnectionManager#createAndOffer() queues the\n        // initial offer in the event queue for the 'description' event. So,\n        // we are dequeueing to prevent the spurious 'update' message sent by\n        // the client after connecting to a room.\n\n        peerConnectionManager.dequeue('description');\n      }).catch(function (error) {\n        log.error('createAndOffer() failed:', error);\n        reject(error);\n        throw error;\n      });\n    };\n\n    var automaticSubscription = options.automaticSubscription,\n        bandwidthProfile = options.bandwidthProfile,\n        dominantSpeaker = options.dominantSpeaker,\n        environment = options.environment,\n        eventObserver = options.eventObserver,\n        loggerName = options.loggerName,\n        logLevel = options.logLevel,\n        name = options.name,\n        networkMonitor = options.networkMonitor,\n        networkQuality = options.networkQuality,\n        realm = options.realm,\n        sdpSemantics = options.sdpSemantics; // decide which msp channels to request\n    // dominantSpeaker, networkQuality\n\n    var trackPriority = !!bandwidthProfile;\n    var trackSwitchOff = !!bandwidthProfile;\n    var renderHints = !!bandwidthProfile && (options.clientTrackSwitchOffControl !== 'disabled' || options.contentPreferencesMode !== 'disabled');\n    var transportOptions = Object.assign({\n      adaptiveSimulcast: adaptiveSimulcast,\n      automaticSubscription: automaticSubscription,\n      dominantSpeaker: dominantSpeaker,\n      environment: environment,\n      eventObserver: eventObserver,\n      loggerName: loggerName,\n      logLevel: logLevel,\n      networkMonitor: networkMonitor,\n      networkQuality: networkQuality,\n      iceServers: iceServers,\n      onIced: onIced,\n      realm: realm,\n      renderHints: renderHints,\n      sdpSemantics: sdpSemantics,\n      trackPriority: trackPriority,\n      trackSwitchOff: trackSwitchOff\n    }, bandwidthProfile ? {\n      bandwidthProfile: bandwidthProfile\n    } : {});\n    transport = new Transport(name, token, localParticipant, peerConnectionManager, wsServer, transportOptions);\n    var connectEventPayload = createRoomConnectEventPayload(options);\n    eventObserver.emit('event', connectEventPayload);\n    transport.once('connected', function (initialState) {\n      log.debug('Transport connected:', initialState);\n\n      if (isCanceled()) {\n        reject(cancellationError);\n        return;\n      }\n\n      var localParticipantState = initialState.participant;\n\n      if (!localParticipantState) {\n        reject(new SignalingIncomingMessageInvalidError());\n        return;\n      }\n\n      var signalingRegion = initialState.options.signaling_region;\n      localParticipant.setSignalingRegion(signalingRegion);\n      resolve(new RoomV2(localParticipant, initialState, transport, peerConnectionManager, options));\n    });\n    transport.once('stateChanged', function (state, error) {\n      if (state === 'disconnected') {\n        transport = null;\n        reject(error || new SignalingConnectionDisconnectedError());\n      } else {\n        log.debug('Transport state changed:', state);\n      }\n    });\n  }, function () {\n    if (transport) {\n      transport.disconnect();\n      transport = null;\n    }\n  });\n  cancelablePromise.catch(function () {\n    if (transport) {\n      transport.disconnect();\n      transport = null;\n    }\n\n    peerConnectionManager.close();\n  });\n  return cancelablePromise;\n}\n\nmodule.exports = createCancelableRoomSignalingPromise;","map":{"version":3,"sources":["../../../lib/signaling/v2/cancelableroomsignalingpromise.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["'use strict';\nvar CancelablePromise = require('../../util/cancelablepromise');\nvar DefaultPeerConnectionManager = require('./peerconnectionmanager');\nvar DefaultRoomV2 = require('./room');\nvar DefaultTransport = require('./twilioconnectiontransport');\nvar _a = require('../../util/twilio-video-errors'), SignalingConnectionDisconnectedError = _a.SignalingConnectionDisconnectedError, SignalingIncomingMessageInvalidError = _a.SignalingIncomingMessageInvalidError;\nvar _b = require('../../util'), flatMap = _b.flatMap, createRoomConnectEventPayload = _b.createRoomConnectEventPayload;\nfunction createCancelableRoomSignalingPromise(token, wsServer, localParticipant, encodingParameters, preferredCodecs, options) {\n    options = Object.assign({\n        PeerConnectionManager: DefaultPeerConnectionManager,\n        RoomV2: DefaultRoomV2,\n        Transport: DefaultTransport\n    }, options);\n    var adaptiveSimulcast = preferredCodecs.video[0] && preferredCodecs.video[0].adaptiveSimulcast === true;\n    var PeerConnectionManager = options.PeerConnectionManager, RoomV2 = options.RoomV2, Transport = options.Transport, iceServers = options.iceServers, log = options.log;\n    var peerConnectionManager = new PeerConnectionManager(encodingParameters, preferredCodecs, options);\n    var trackSenders = flatMap(localParticipant.tracks, function (trackV2) { return [trackV2.trackTransceiver]; });\n    peerConnectionManager.setTrackSenders(trackSenders);\n    var cancellationError = new Error('Canceled');\n    var transport;\n    var cancelablePromise = new CancelablePromise(function (resolve, reject, isCanceled) {\n        var onIced = function (iceServers) {\n            if (isCanceled()) {\n                reject(cancellationError);\n                return Promise.reject(cancellationError);\n            }\n            log.debug('Got ICE servers:', iceServers);\n            options.iceServers = iceServers;\n            peerConnectionManager.setConfiguration(options);\n            return peerConnectionManager.createAndOffer().then(function () {\n                if (isCanceled()) {\n                    reject(cancellationError);\n                    throw cancellationError;\n                }\n                log.debug('createAndOffer() succeeded.');\n                // NOTE(mmalavalli): PeerConnectionManager#createAndOffer() queues the\n                // initial offer in the event queue for the 'description' event. So,\n                // we are dequeueing to prevent the spurious 'update' message sent by\n                // the client after connecting to a room.\n                peerConnectionManager.dequeue('description');\n            }).catch(function (error) {\n                log.error('createAndOffer() failed:', error);\n                reject(error);\n                throw error;\n            });\n        };\n        var automaticSubscription = options.automaticSubscription, bandwidthProfile = options.bandwidthProfile, dominantSpeaker = options.dominantSpeaker, environment = options.environment, eventObserver = options.eventObserver, loggerName = options.loggerName, logLevel = options.logLevel, name = options.name, networkMonitor = options.networkMonitor, networkQuality = options.networkQuality, realm = options.realm, sdpSemantics = options.sdpSemantics;\n        // decide which msp channels to request\n        // dominantSpeaker, networkQuality\n        var trackPriority = !!bandwidthProfile;\n        var trackSwitchOff = !!bandwidthProfile;\n        var renderHints = !!bandwidthProfile &&\n            (options.clientTrackSwitchOffControl !== 'disabled' || options.contentPreferencesMode !== 'disabled');\n        var transportOptions = Object.assign({\n            adaptiveSimulcast: adaptiveSimulcast,\n            automaticSubscription: automaticSubscription,\n            dominantSpeaker: dominantSpeaker,\n            environment: environment,\n            eventObserver: eventObserver,\n            loggerName: loggerName,\n            logLevel: logLevel,\n            networkMonitor: networkMonitor,\n            networkQuality: networkQuality,\n            iceServers: iceServers,\n            onIced: onIced,\n            realm: realm,\n            renderHints: renderHints,\n            sdpSemantics: sdpSemantics,\n            trackPriority: trackPriority,\n            trackSwitchOff: trackSwitchOff\n        }, bandwidthProfile ? {\n            bandwidthProfile: bandwidthProfile\n        } : {});\n        transport = new Transport(name, token, localParticipant, peerConnectionManager, wsServer, transportOptions);\n        var connectEventPayload = createRoomConnectEventPayload(options);\n        eventObserver.emit('event', connectEventPayload);\n        transport.once('connected', function (initialState) {\n            log.debug('Transport connected:', initialState);\n            if (isCanceled()) {\n                reject(cancellationError);\n                return;\n            }\n            var localParticipantState = initialState.participant;\n            if (!localParticipantState) {\n                reject(new SignalingIncomingMessageInvalidError());\n                return;\n            }\n            var signalingRegion = initialState.options.signaling_region;\n            localParticipant.setSignalingRegion(signalingRegion);\n            resolve(new RoomV2(localParticipant, initialState, transport, peerConnectionManager, options));\n        });\n        transport.once('stateChanged', function (state, error) {\n            if (state === 'disconnected') {\n                transport = null;\n                reject(error || new SignalingConnectionDisconnectedError());\n            }\n            else {\n                log.debug('Transport state changed:', state);\n            }\n        });\n    }, function () {\n        if (transport) {\n            transport.disconnect();\n            transport = null;\n        }\n    });\n    cancelablePromise.catch(function () {\n        if (transport) {\n            transport.disconnect();\n            transport = null;\n        }\n        peerConnectionManager.close();\n    });\n    return cancelablePromise;\n}\nmodule.exports = createCancelableRoomSignalingPromise;\n//# sourceMappingURL=cancelableroomsignalingpromise.js.map"]},"metadata":{},"sourceType":"script"}