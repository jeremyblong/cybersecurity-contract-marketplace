{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n * @typedef {import('micromark-util-types').CompileContext} CompileContext\n *\n * @typedef Options\n * @property {string} [clobberPrefix='user-content-']\n *   Prefix to use before the `id` attribute to prevent it from *clobbering*.\n *   attributes.\n *   DOM clobbering is this:\n *\n *   ```html\n *   <p id=x></p>\n *   <script>alert(x)</script>\n *   ```\n *\n *   Elements by their ID are made available in browsers on the `window` object.\n *   Using a prefix prevents this from being a problem.\n * @property {string} [label='Footnotes']\n *   Label to use for the footnotes section.\n *   Affects screen reader users.\n *   Change it if you’re authoring in a different language.\n * @property {string} [backLabel='Back to content']\n *   Label to use from backreferences back to their footnote call.\n *   Affects screen reader users.\n *   Change it if you’re authoring in a different language.\n */\nimport { normalizeIdentifier } from 'micromark-util-normalize-identifier';\nimport { sanitizeUri } from 'micromark-util-sanitize-uri';\nconst own = {}.hasOwnProperty;\n/**\n * @param {Options} [options={}]\n * @returns {HtmlExtension}\n */\n\nexport function gfmFootnoteHtml() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const label = options.label || 'Footnotes';\n  const backLabel = options.backLabel || 'Back to content';\n  const clobberPrefix = options.clobberPrefix === undefined || options.clobberPrefix === null ? 'user-content-' : options.clobberPrefix;\n  return {\n    enter: {\n      gfmFootnoteDefinition() {\n        // @ts-expect-error It’s defined.\n        this.getData('tightStack').push(false);\n      },\n\n      gfmFootnoteDefinitionLabelString() {\n        this.buffer();\n      },\n\n      gfmFootnoteCallString() {\n        this.buffer();\n      }\n\n    },\n    exit: {\n      gfmFootnoteDefinition() {\n        /** @type {Record<string, string>} */\n        // @ts-expect-error It’s fine.\n        let definitions = this.getData('gfmFootnoteDefinitions');\n        /** @type {string[]} */\n        // @ts-expect-error: It’s fine\n\n        const stack = this.getData('gfmFootnoteDefinitionStack');\n        /** @type {string} */\n        // @ts-expect-error: It’s fine\n\n        const current = stack.pop();\n        const value = this.resume();\n        if (!definitions) this.setData('gfmFootnoteDefinitions', definitions = {});\n        if (!own.call(definitions, current)) definitions[current] = value; // @ts-expect-error It’s defined.\n\n        this.getData('tightStack').pop();\n        this.setData('slurpOneLineEnding', true); // “Hack” to prevent a line ending from showing up if we’re in a definition in\n        // an empty list item.\n\n        this.setData('lastWasTag');\n      },\n\n      gfmFootnoteDefinitionLabelString(token) {\n        /** @type {string[]} */\n        // @ts-expect-error: It’s fine\n        let stack = this.getData('gfmFootnoteDefinitionStack');\n        if (!stack) this.setData('gfmFootnoteDefinitionStack', stack = []);\n        stack.push(normalizeIdentifier(this.sliceSerialize(token)));\n        this.resume(); // Drop the label.\n\n        this.buffer(); // Get ready for a value.\n      },\n\n      gfmFootnoteCallString(token) {\n        /** @type {string[]|undefined} */\n        // @ts-expect-error It’s fine.\n        let calls = this.getData('gfmFootnoteCallOrder');\n        /** @type {Record.<string, number>|undefined} */\n        // @ts-expect-error It’s fine.\n\n        let counts = this.getData('gfmFootnoteCallCounts');\n        const id = normalizeIdentifier(this.sliceSerialize(token));\n        /** @type {number} */\n\n        let counter;\n        this.resume();\n        if (!calls) this.setData('gfmFootnoteCallOrder', calls = []);\n        if (!counts) this.setData('gfmFootnoteCallCounts', counts = {});\n        const index = calls.indexOf(id);\n        const safeId = sanitizeUri(id.toLowerCase());\n\n        if (index === -1) {\n          calls.push(id);\n          counts[id] = 1;\n          counter = calls.length;\n        } else {\n          counts[id]++;\n          counter = index + 1;\n        }\n\n        const reuseCounter = counts[id];\n        this.tag('<sup><a href=\"#' + clobberPrefix + 'fn-' + safeId + '\" id=\"' + clobberPrefix + 'fnref-' + safeId + (reuseCounter > 1 ? '-' + reuseCounter : '') + '\" data-footnote-ref=\"\" aria-describedby=\"footnote-label\">' + String(counter) + '</a></sup>');\n      },\n\n      null() {\n        /** @type {string[]} */\n        // @ts-expect-error It’s fine.\n        const calls = this.getData('gfmFootnoteCallOrder') || [];\n        /** @type {Record.<string, number>} */\n        // @ts-expect-error It’s fine.\n\n        const counts = this.getData('gfmFootnoteCallCounts') || {};\n        /** @type {Record<string, string>} */\n        // @ts-expect-error It’s fine.\n\n        const definitions = this.getData('gfmFootnoteDefinitions') || {};\n        let index = -1;\n\n        if (calls.length > 0) {\n          this.lineEndingIfNeeded();\n          this.tag('<section data-footnotes=\"\" class=\"footnotes\"><h2 id=\"footnote-label\" class=\"sr-only\">');\n          this.raw(this.encode(label));\n          this.tag('</h2>');\n          this.lineEndingIfNeeded();\n          this.tag('<ol>');\n        }\n\n        while (++index < calls.length) {\n          // Called definitions are always defined.\n          const id = calls[index];\n          const safeId = sanitizeUri(id.toLowerCase());\n          let referenceIndex = 0;\n          /** @type {string[]} */\n\n          const references = [];\n\n          while (++referenceIndex <= counts[id]) {\n            references.push('<a href=\"#' + clobberPrefix + 'fnref-' + safeId + (referenceIndex > 1 ? '-' + referenceIndex : '') + '\" data-footnote-backref=\"\" class=\"data-footnote-backref\" aria-label=\"' + this.encode(backLabel) + '\">↩' + (referenceIndex > 1 ? '<sup>' + referenceIndex + '</sup>' : '') + '</a>');\n          }\n\n          const reference = references.join(' ');\n          let injected = false;\n          this.lineEndingIfNeeded();\n          this.tag('<li id=\"' + clobberPrefix + 'fn-' + safeId + '\">');\n          this.lineEndingIfNeeded();\n          this.tag(definitions[id].replace(/<\\/p>(?:\\r?\\n|\\r)?$/, (\n          /** @type {string} */\n          $0) => {\n            injected = true;\n            return ' ' + reference + $0;\n          }));\n\n          if (!injected) {\n            this.lineEndingIfNeeded();\n            this.tag(reference);\n          }\n\n          this.lineEndingIfNeeded();\n          this.tag('</li>');\n        }\n\n        if (calls.length > 0) {\n          this.lineEndingIfNeeded();\n          this.tag('</ol>');\n          this.lineEndingIfNeeded();\n          this.tag('</section>');\n        }\n      }\n\n    }\n  };\n}","map":{"version":3,"sources":["/home/kali/Documents/cybersecurity/client/node_modules/micromark-extension-gfm-footnote/lib/html.js"],"names":["normalizeIdentifier","sanitizeUri","own","hasOwnProperty","gfmFootnoteHtml","options","label","backLabel","clobberPrefix","undefined","enter","gfmFootnoteDefinition","getData","push","gfmFootnoteDefinitionLabelString","buffer","gfmFootnoteCallString","exit","definitions","stack","current","pop","value","resume","setData","call","token","sliceSerialize","calls","counts","id","counter","index","indexOf","safeId","toLowerCase","length","reuseCounter","tag","String","null","lineEndingIfNeeded","raw","encode","referenceIndex","references","reference","join","injected","replace","$0"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n * @typedef {import('micromark-util-types').CompileContext} CompileContext\n *\n * @typedef Options\n * @property {string} [clobberPrefix='user-content-']\n *   Prefix to use before the `id` attribute to prevent it from *clobbering*.\n *   attributes.\n *   DOM clobbering is this:\n *\n *   ```html\n *   <p id=x></p>\n *   <script>alert(x)</script>\n *   ```\n *\n *   Elements by their ID are made available in browsers on the `window` object.\n *   Using a prefix prevents this from being a problem.\n * @property {string} [label='Footnotes']\n *   Label to use for the footnotes section.\n *   Affects screen reader users.\n *   Change it if you’re authoring in a different language.\n * @property {string} [backLabel='Back to content']\n *   Label to use from backreferences back to their footnote call.\n *   Affects screen reader users.\n *   Change it if you’re authoring in a different language.\n */\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {sanitizeUri} from 'micromark-util-sanitize-uri'\nconst own = {}.hasOwnProperty\n/**\n * @param {Options} [options={}]\n * @returns {HtmlExtension}\n */\n\nexport function gfmFootnoteHtml(options = {}) {\n  const label = options.label || 'Footnotes'\n  const backLabel = options.backLabel || 'Back to content'\n  const clobberPrefix =\n    options.clobberPrefix === undefined || options.clobberPrefix === null\n      ? 'user-content-'\n      : options.clobberPrefix\n  return {\n    enter: {\n      gfmFootnoteDefinition() {\n        // @ts-expect-error It’s defined.\n        this.getData('tightStack').push(false)\n      },\n\n      gfmFootnoteDefinitionLabelString() {\n        this.buffer()\n      },\n\n      gfmFootnoteCallString() {\n        this.buffer()\n      }\n    },\n    exit: {\n      gfmFootnoteDefinition() {\n        /** @type {Record<string, string>} */\n        // @ts-expect-error It’s fine.\n        let definitions = this.getData('gfmFootnoteDefinitions')\n        /** @type {string[]} */\n        // @ts-expect-error: It’s fine\n\n        const stack = this.getData('gfmFootnoteDefinitionStack')\n        /** @type {string} */\n        // @ts-expect-error: It’s fine\n\n        const current = stack.pop()\n        const value = this.resume()\n        if (!definitions)\n          this.setData('gfmFootnoteDefinitions', (definitions = {}))\n        if (!own.call(definitions, current)) definitions[current] = value // @ts-expect-error It’s defined.\n\n        this.getData('tightStack').pop()\n        this.setData('slurpOneLineEnding', true) // “Hack” to prevent a line ending from showing up if we’re in a definition in\n        // an empty list item.\n\n        this.setData('lastWasTag')\n      },\n\n      gfmFootnoteDefinitionLabelString(token) {\n        /** @type {string[]} */\n        // @ts-expect-error: It’s fine\n        let stack = this.getData('gfmFootnoteDefinitionStack')\n        if (!stack) this.setData('gfmFootnoteDefinitionStack', (stack = []))\n        stack.push(normalizeIdentifier(this.sliceSerialize(token)))\n        this.resume() // Drop the label.\n\n        this.buffer() // Get ready for a value.\n      },\n\n      gfmFootnoteCallString(token) {\n        /** @type {string[]|undefined} */\n        // @ts-expect-error It’s fine.\n        let calls = this.getData('gfmFootnoteCallOrder')\n        /** @type {Record.<string, number>|undefined} */\n        // @ts-expect-error It’s fine.\n\n        let counts = this.getData('gfmFootnoteCallCounts')\n        const id = normalizeIdentifier(this.sliceSerialize(token))\n        /** @type {number} */\n\n        let counter\n        this.resume()\n        if (!calls) this.setData('gfmFootnoteCallOrder', (calls = []))\n        if (!counts) this.setData('gfmFootnoteCallCounts', (counts = {}))\n        const index = calls.indexOf(id)\n        const safeId = sanitizeUri(id.toLowerCase())\n\n        if (index === -1) {\n          calls.push(id)\n          counts[id] = 1\n          counter = calls.length\n        } else {\n          counts[id]++\n          counter = index + 1\n        }\n\n        const reuseCounter = counts[id]\n        this.tag(\n          '<sup><a href=\"#' +\n            clobberPrefix +\n            'fn-' +\n            safeId +\n            '\" id=\"' +\n            clobberPrefix +\n            'fnref-' +\n            safeId +\n            (reuseCounter > 1 ? '-' + reuseCounter : '') +\n            '\" data-footnote-ref=\"\" aria-describedby=\"footnote-label\">' +\n            String(counter) +\n            '</a></sup>'\n        )\n      },\n\n      null() {\n        /** @type {string[]} */\n        // @ts-expect-error It’s fine.\n        const calls = this.getData('gfmFootnoteCallOrder') || []\n        /** @type {Record.<string, number>} */\n        // @ts-expect-error It’s fine.\n\n        const counts = this.getData('gfmFootnoteCallCounts') || {}\n        /** @type {Record<string, string>} */\n        // @ts-expect-error It’s fine.\n\n        const definitions = this.getData('gfmFootnoteDefinitions') || {}\n        let index = -1\n\n        if (calls.length > 0) {\n          this.lineEndingIfNeeded()\n          this.tag(\n            '<section data-footnotes=\"\" class=\"footnotes\"><h2 id=\"footnote-label\" class=\"sr-only\">'\n          )\n          this.raw(this.encode(label))\n          this.tag('</h2>')\n          this.lineEndingIfNeeded()\n          this.tag('<ol>')\n        }\n\n        while (++index < calls.length) {\n          // Called definitions are always defined.\n          const id = calls[index]\n          const safeId = sanitizeUri(id.toLowerCase())\n          let referenceIndex = 0\n          /** @type {string[]} */\n\n          const references = []\n\n          while (++referenceIndex <= counts[id]) {\n            references.push(\n              '<a href=\"#' +\n                clobberPrefix +\n                'fnref-' +\n                safeId +\n                (referenceIndex > 1 ? '-' + referenceIndex : '') +\n                '\" data-footnote-backref=\"\" class=\"data-footnote-backref\" aria-label=\"' +\n                this.encode(backLabel) +\n                '\">↩' +\n                (referenceIndex > 1\n                  ? '<sup>' + referenceIndex + '</sup>'\n                  : '') +\n                '</a>'\n            )\n          }\n\n          const reference = references.join(' ')\n          let injected = false\n          this.lineEndingIfNeeded()\n          this.tag('<li id=\"' + clobberPrefix + 'fn-' + safeId + '\">')\n          this.lineEndingIfNeeded()\n          this.tag(\n            definitions[id].replace(\n              /<\\/p>(?:\\r?\\n|\\r)?$/,\n              (\n                /** @type {string} */\n                $0\n              ) => {\n                injected = true\n                return ' ' + reference + $0\n              }\n            )\n          )\n\n          if (!injected) {\n            this.lineEndingIfNeeded()\n            this.tag(reference)\n          }\n\n          this.lineEndingIfNeeded()\n          this.tag('</li>')\n        }\n\n        if (calls.length > 0) {\n          this.lineEndingIfNeeded()\n          this.tag('</ol>')\n          this.lineEndingIfNeeded()\n          this.tag('</section>')\n        }\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}